/* Minification failed. Returning unminified contents.
(2066,37-38): run-time warning JS1004: Expected ';': d
(2067,37-38): run-time warning JS1004: Expected ';': d
 */
/*! jQuery Validation Plugin - v1.12.0 - 4/1/2014
 * http://jqueryvalidation.org/
 * Copyright (c) 2014 JÃ¶rn Zaefferer; Licensed MIT */
!function (a) { a.extend(a.fn, { validate: function (b) { if (!this.length) return void (b && b.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing.")); var c = a.data(this[0], "validator"); return c ? c : (this.attr("novalidate", "novalidate"), c = new a.validator(b, this[0]), a.data(this[0], "validator", c), c.settings.onsubmit && (this.validateDelegate(":submit", "click", function (b) { c.settings.submitHandler && (c.submitButton = b.target), a(b.target).hasClass("cancel") && (c.cancelSubmit = !0), void 0 !== a(b.target).attr("formnovalidate") && (c.cancelSubmit = !0) }), this.submit(function (b) { function d() { var d; return c.settings.submitHandler ? (c.submitButton && (d = a("<input type='hidden'/>").attr("name", c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)), c.settings.submitHandler.call(c, c.currentForm, b), c.submitButton && d.remove(), !1) : !0 } return c.settings.debug && b.preventDefault(), c.cancelSubmit ? (c.cancelSubmit = !1, d()) : c.form() ? c.pendingRequest ? (c.formSubmitted = !0, !1) : d() : (c.focusInvalid(), !1) })), c) }, valid: function () { var b, c; return a(this[0]).is("form") ? b = this.validate().form() : (b = !0, c = a(this[0].form).validate(), this.each(function () { b = c.element(this) && b })), b }, removeAttrs: function (b) { var c = {}, d = this; return a.each(b.split(/\s/), function (a, b) { c[b] = d.attr(b), d.removeAttr(b) }), c }, rules: function (b, c) { var d, e, f, g, h, i, j = this[0]; if (b) switch (d = a.data(j.form, "validator").settings, e = d.rules, f = a.validator.staticRules(j), b) { case "add": a.extend(f, a.validator.normalizeRule(c)), delete f.messages, e[j.name] = f, c.messages && (d.messages[j.name] = a.extend(d.messages[j.name], c.messages)); break; case "remove": return c ? (i = {}, a.each(c.split(/\s/), function (b, c) { i[c] = f[c], delete f[c], "required" === c && a(j).removeAttr("aria-required") }), i) : (delete e[j.name], f) } return g = a.validator.normalizeRules(a.extend({}, a.validator.classRules(j), a.validator.attributeRules(j), a.validator.dataRules(j), a.validator.staticRules(j)), j), g.required && (h = g.required, delete g.required, g = a.extend({ required: h }, g), a(j).attr("aria-required", "true")), g.remote && (h = g.remote, delete g.remote, g = a.extend(g, { remote: h })), g } }), a.extend(a.expr[":"], { blank: function (b) { return !a.trim("" + a(b).val()) }, filled: function (b) { return !!a.trim("" + a(b).val()) }, unchecked: function (b) { return !a(b).prop("checked") } }), a.validator = function (b, c) { this.settings = a.extend(!0, {}, a.validator.defaults, b), this.currentForm = c, this.init() }, a.validator.format = function (b, c) { return 1 === arguments.length ? function () { var c = a.makeArray(arguments); return c.unshift(b), a.validator.format.apply(this, c) } : (arguments.length > 2 && c.constructor !== Array && (c = a.makeArray(arguments).slice(1)), c.constructor !== Array && (c = [c]), a.each(c, function (a, c) { b = b.replace(new RegExp("\\{" + a + "\\}", "g"), function () { return c }) }), b) }, a.extend(a.validator, { defaults: { messages: {}, groups: {}, rules: {}, errorClass: "error", validClass: "valid", errorElement: "label", focusInvalid: !0, errorContainer: a([]), errorLabelContainer: a([]), onsubmit: !0, ignore: ":hidden", ignoreTitle: !1, onfocusin: function (a) { this.lastActive = a, this.settings.focusCleanup && !this.blockFocusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, a, this.settings.errorClass, this.settings.validClass), this.addWrapper(this.errorsFor(a)).hide()) }, onfocusout: function (a) { this.checkable(a) || !(a.name in this.submitted) && this.optional(a) || this.element(a) }, onkeyup: function (a, b) { (9 !== b.which || "" !== this.elementValue(a)) && (a.name in this.submitted || a === this.lastElement) && this.element(a) }, onclick: function (a) { a.name in this.submitted ? this.element(a) : a.parentNode.name in this.submitted && this.element(a.parentNode) }, highlight: function (b, c, d) { "radio" === b.type ? this.findByName(b.name).addClass(c).removeClass(d) : a(b).addClass(c).removeClass(d) }, unhighlight: function (b, c, d) { "radio" === b.type ? this.findByName(b.name).removeClass(c).addClass(d) : a(b).removeClass(c).addClass(d) } }, setDefaults: function (b) { a.extend(a.validator.defaults, b) }, messages: { required: "This field is required.", remote: "Please fix this field.", email: "Please enter a valid email address.", url: "Please enter a valid URL.", date: "Please enter a valid date.", dateISO: "Please enter a valid date (ISO).", number: "Please enter a valid number.", digits: "Please enter only digits.", creditcard: "Please enter a valid credit card number.", equalTo: "Please enter the same value again.", maxlength: a.validator.format("Please enter no more than {0} characters."), minlength: a.validator.format("Please enter at least {0} characters."), rangelength: a.validator.format("Please enter a value between {0} and {1} characters long."), range: a.validator.format("Please enter a value between {0} and {1}."), max: a.validator.format("Please enter a value less than or equal to {0}."), min: a.validator.format("Please enter a value greater than or equal to {0}.") }, autoCreateRanges: !1, prototype: { init: function () { function b(b) { var c = a.data(this[0].form, "validator"), d = "on" + b.type.replace(/^validate/, ""), e = c.settings; e[d] && !this.is(e.ignore) && e[d].call(c, this[0], b) } this.labelContainer = a(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || a(this.currentForm), this.containers = a(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset(); var c, d = this.groups = {}; a.each(this.settings.groups, function (b, c) { "string" == typeof c && (c = c.split(/\s/)), a.each(c, function (a, c) { d[c] = b }) }), c = this.settings.rules, a.each(c, function (b, d) { c[b] = a.validator.normalizeRule(d) }), a(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'] ", "focusin focusout keyup", b).validateDelegate("[type='radio'], [type='checkbox'], select, option", "click", b), this.settings.invalidHandler && a(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler), a(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true") }, form: function () { return this.checkForm(), a.extend(this.submitted, this.errorMap), this.invalid = a.extend({}, this.errorMap), this.valid() || a(this.currentForm).triggerHandler("invalid-form", [this]), this.showErrors(), this.valid() }, checkForm: function () { this.prepareForm(); for (var a = 0, b = this.currentElements = this.elements() ; b[a]; a++) this.check(b[a]); return this.valid() }, element: function (b) { var c = this.clean(b), d = this.validationTargetFor(c), e = !0; return this.lastElement = d, void 0 === d ? delete this.invalid[c.name] : (this.prepareElement(d), this.currentElements = a(d), e = this.check(d) !== !1, e ? delete this.invalid[d.name] : this.invalid[d.name] = !0), a(b).attr("aria-invalid", !e), this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), e }, showErrors: function (b) { if (b) { a.extend(this.errorMap, b), this.errorList = []; for (var c in b) this.errorList.push({ message: b[c], element: this.findByName(c)[0] }); this.successList = a.grep(this.successList, function (a) { return !(a.name in b) }) } this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors() }, resetForm: function () { a.fn.resetForm && a(this.currentForm).resetForm(), this.submitted = {}, this.lastElement = null, this.prepareForm(), this.hideErrors(), this.elements().removeClass(this.settings.errorClass).removeData("previousValue").removeAttr("aria-invalid") }, numberOfInvalids: function () { return this.objectLength(this.invalid) }, objectLength: function (a) { var b, c = 0; for (b in a) c++; return c }, hideErrors: function () { this.addWrapper(this.toHide).hide() }, valid: function () { return 0 === this.size() }, size: function () { return this.errorList.length }, focusInvalid: function () { if (this.settings.focusInvalid) try { a(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin") } catch (b) { } }, findLastActive: function () { var b = this.lastActive; return b && 1 === a.grep(this.errorList, function (a) { return a.element.name === b.name }).length && b }, elements: function () { var b = this, c = {}; return a(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function () { return !this.name && b.settings.debug && window.console && console.error("%o has no name assigned", this), this.name in c || !b.objectLength(a(this).rules()) ? !1 : (c[this.name] = !0, !0) }) }, clean: function (b) { return a(b)[0] }, errors: function () { var b = this.settings.errorClass.split(" ").join("."); return a(this.settings.errorElement + "." + b, this.errorContext) }, reset: function () { this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = a([]), this.toHide = a([]), this.currentElements = a([]) }, prepareForm: function () { this.reset(), this.toHide = this.errors().add(this.containers) }, prepareElement: function (a) { this.reset(), this.toHide = this.errorsFor(a) }, elementValue: function (b) { var c, d = a(b), e = d.attr("type"); return "radio" === e || "checkbox" === e ? a("input[name='" + d.attr("name") + "']:checked").val() : (c = d.val(), "string" == typeof c ? c.replace(/\r/g, "") : c) }, check: function (b) { b = this.validationTargetFor(this.clean(b)); var c, d, e, f = a(b).rules(), g = a.map(f, function (a, b) { return b }).length, h = !1, i = this.elementValue(b); for (d in f) { e = { method: d, parameters: f[d] }; try { if (c = a.validator.methods[d].call(this, i, b, e.parameters), "dependency-mismatch" === c && 1 === g) { h = !0; continue } if (h = !1, "pending" === c) return void (this.toHide = this.toHide.not(this.errorsFor(b))); if (!c) return this.formatAndAdd(b, e), !1 } catch (j) { throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + b.id + ", check the '" + e.method + "' method.", j), j } } if (!h) return this.objectLength(f) && this.successList.push(b), !0 }, customDataMessage: function (b, c) { return a(b).data("msg" + c[0].toUpperCase() + c.substring(1).toLowerCase()) || a(b).data("msg") }, customMessage: function (a, b) { var c = this.settings.messages[a]; return c && (c.constructor === String ? c : c[b]) }, findDefined: function () { for (var a = 0; a < arguments.length; a++) if (void 0 !== arguments[a]) return arguments[a]; return void 0 }, defaultMessage: function (b, c) { return this.findDefined(this.customMessage(b.name, c), this.customDataMessage(b, c), !this.settings.ignoreTitle && b.title || void 0, a.validator.messages[c], "<strong>Warning: No message defined for " + b.name + "</strong>") }, formatAndAdd: function (b, c) { var d = this.defaultMessage(b, c.method), e = /\$?\{(\d+)\}/g; "function" == typeof d ? d = d.call(this, c.parameters, b) : e.test(d) && (d = a.validator.format(d.replace(e, "{$1}"), c.parameters)), this.errorList.push({ message: d, element: b, method: c.method }), this.errorMap[b.name] = d, this.submitted[b.name] = d }, addWrapper: function (a) { return this.settings.wrapper && (a = a.add(a.parent(this.settings.wrapper))), a }, defaultShowErrors: function () { var a, b, c; for (a = 0; this.errorList[a]; a++) c = this.errorList[a], this.settings.highlight && this.settings.highlight.call(this, c.element, this.settings.errorClass, this.settings.validClass), this.showLabel(c.element, c.message); if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) for (a = 0; this.successList[a]; a++) this.showLabel(this.successList[a]); if (this.settings.unhighlight) for (a = 0, b = this.validElements() ; b[a]; a++) this.settings.unhighlight.call(this, b[a], this.settings.errorClass, this.settings.validClass); this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show() }, validElements: function () { return this.currentElements.not(this.invalidElements()) }, invalidElements: function () { return a(this.errorList).map(function () { return this.element }) }, showLabel: function (b, c) { var d = this.errorsFor(b); d.length ? (d.removeClass(this.settings.validClass).addClass(this.settings.errorClass), d.html(c)) : (d = a("<" + this.settings.errorElement + ">").attr("for", this.idOrName(b)).addClass(this.settings.errorClass).html(c || ""), this.settings.wrapper && (d = d.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()), this.labelContainer.append(d).length || (this.settings.errorPlacement ? this.settings.errorPlacement(d, a(b)) : d.insertAfter(b))), !c && this.settings.success && (d.text(""), "string" == typeof this.settings.success ? d.addClass(this.settings.success) : this.settings.success(d, b)), this.toShow = this.toShow.add(d) }, errorsFor: function (b) { var c = this.idOrName(b); return this.errors().filter(function () { return a(this).attr("for") === c }) }, idOrName: function (a) { return this.groups[a.name] || (this.checkable(a) ? a.name : a.id || a.name) }, validationTargetFor: function (a) { return this.checkable(a) && (a = this.findByName(a.name).not(this.settings.ignore)[0]), a }, checkable: function (a) { return /radio|checkbox/i.test(a.type) }, findByName: function (b) { return a(this.currentForm).find("[name='" + b + "']") }, getLength: function (b, c) { switch (c.nodeName.toLowerCase()) { case "select": return a("option:selected", c).length; case "input": if (this.checkable(c)) return this.findByName(c.name).filter(":checked").length } return b.length }, depend: function (a, b) { return this.dependTypes[typeof a] ? this.dependTypes[typeof a](a, b) : !0 }, dependTypes: { "boolean": function (a) { return a }, string: function (b, c) { return !!a(b, c.form).length }, "function": function (a, b) { return a(b) } }, optional: function (b) { var c = this.elementValue(b); return !a.validator.methods.required.call(this, c, b) && "dependency-mismatch" }, startRequest: function (a) { this.pending[a.name] || (this.pendingRequest++, this.pending[a.name] = !0) }, stopRequest: function (b, c) { this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[b.name], c && 0 === this.pendingRequest && this.formSubmitted && this.form() ? (a(this.currentForm).submit(), this.formSubmitted = !1) : !c && 0 === this.pendingRequest && this.formSubmitted && (a(this.currentForm).triggerHandler("invalid-form", [this]), this.formSubmitted = !1) }, previousValue: function (b) { return a.data(b, "previousValue") || a.data(b, "previousValue", { old: null, valid: !0, message: this.defaultMessage(b, "remote") }) } }, classRuleSettings: { required: { required: !0 }, email: { email: !0 }, url: { url: !0 }, date: { date: !0 }, dateISO: { dateISO: !0 }, number: { number: !0 }, digits: { digits: !0 }, creditcard: { creditcard: !0 } }, addClassRules: function (b, c) { b.constructor === String ? this.classRuleSettings[b] = c : a.extend(this.classRuleSettings, b) }, classRules: function (b) { var c = {}, d = a(b).attr("class"); return d && a.each(d.split(" "), function () { this in a.validator.classRuleSettings && a.extend(c, a.validator.classRuleSettings[this]) }), c }, attributeRules: function (b) { var c, d, e = {}, f = a(b), g = b.getAttribute("type"); for (c in a.validator.methods) "required" === c ? (d = b.getAttribute(c), "" === d && (d = !0), d = !!d) : d = f.attr(c), /min|max/.test(c) && (null === g || /number|range|text/.test(g)) && (d = Number(d)), d || 0 === d ? e[c] = d : g === c && "range" !== g && (e[c] = !0); return e.maxlength && /-1|2147483647|524288/.test(e.maxlength) && delete e.maxlength, e }, dataRules: function (b) { var c, d, e = {}, f = a(b); for (c in a.validator.methods) d = f.data("rule" + c[0].toUpperCase() + c.substring(1).toLowerCase()), void 0 !== d && (e[c] = d); return e }, staticRules: function (b) { var c = {}, d = a.data(b.form, "validator"); return d.settings.rules && (c = a.validator.normalizeRule(d.settings.rules[b.name]) || {}), c }, normalizeRules: function (b, c) { return a.each(b, function (d, e) { if (e === !1) return void delete b[d]; if (e.param || e.depends) { var f = !0; switch (typeof e.depends) { case "string": f = !!a(e.depends, c.form).length; break; case "function": f = e.depends.call(c, c) } f ? b[d] = void 0 !== e.param ? e.param : !0 : delete b[d] } }), a.each(b, function (d, e) { b[d] = a.isFunction(e) ? e(c) : e }), a.each(["minlength", "maxlength"], function () { b[this] && (b[this] = Number(b[this])) }), a.each(["rangelength", "range"], function () { var c; b[this] && (a.isArray(b[this]) ? b[this] = [Number(b[this][0]), Number(b[this][1])] : "string" == typeof b[this] && (c = b[this].split(/[\s,]+/), b[this] = [Number(c[0]), Number(c[1])])) }), a.validator.autoCreateRanges && (b.min && b.max && (b.range = [b.min, b.max], delete b.min, delete b.max), b.minlength && b.maxlength && (b.rangelength = [b.minlength, b.maxlength], delete b.minlength, delete b.maxlength)), b }, normalizeRule: function (b) { if ("string" == typeof b) { var c = {}; a.each(b.split(/\s/), function () { c[this] = !0 }), b = c } return b }, addMethod: function (b, c, d) { a.validator.methods[b] = c, a.validator.messages[b] = void 0 !== d ? d : a.validator.messages[b], c.length < 3 && a.validator.addClassRules(b, a.validator.normalizeRule(b)) }, methods: { required: function (b, c, d) { if (!this.depend(d, c)) return "dependency-mismatch"; if ("select" === c.nodeName.toLowerCase()) { var e = a(c).val(); return e && e.length > 0 } return this.checkable(c) ? this.getLength(b, c) > 0 : a.trim(b).length > 0 }, email: function (a, b) { return this.optional(b) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a) }, url: function (a, b) { return this.optional(b) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(a) }, date: function (a, b) { return this.optional(b) || !/Invalid|NaN/.test(new Date(a).toString()) }, dateISO: function (a, b) { return this.optional(b) || /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/.test(a) }, number: function (a, b) { return this.optional(b) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(a) }, digits: function (a, b) { return this.optional(b) || /^\d+$/.test(a) }, creditcard: function (a, b) { if (this.optional(b)) return "dependency-mismatch"; if (/[^0-9 \-]+/.test(a)) return !1; var c, d, e = 0, f = 0, g = !1; if (a = a.replace(/\D/g, ""), a.length < 13 || a.length > 19) return !1; for (c = a.length - 1; c >= 0; c--) d = a.charAt(c), f = parseInt(d, 10), g && (f *= 2) > 9 && (f -= 9), e += f, g = !g; return e % 10 === 0 }, minlength: function (b, c, d) { var e = a.isArray(b) ? b.length : this.getLength(a.trim(b), c); return this.optional(c) || e >= d }, maxlength: function (b, c, d) { var e = a.isArray(b) ? b.length : this.getLength(a.trim(b), c); return this.optional(c) || d >= e }, rangelength: function (b, c, d) { var e = a.isArray(b) ? b.length : this.getLength(a.trim(b), c); return this.optional(c) || e >= d[0] && e <= d[1] }, min: function (a, b, c) { return this.optional(b) || a >= c }, max: function (a, b, c) { return this.optional(b) || c >= a }, range: function (a, b, c) { return this.optional(b) || a >= c[0] && a <= c[1] }, equalTo: function (b, c, d) { var e = a(d); return this.settings.onfocusout && e.unbind(".validate-equalTo").bind("blur.validate-equalTo", function () { a(c).valid() }), b === e.val() }, remote: function (b, c, d) { if (this.optional(c)) return "dependency-mismatch"; var e, f, g = this.previousValue(c); return this.settings.messages[c.name] || (this.settings.messages[c.name] = {}), g.originalMessage = this.settings.messages[c.name].remote, this.settings.messages[c.name].remote = g.message, d = "string" == typeof d && { url: d } || d, g.old === b ? g.valid : (g.old = b, e = this, this.startRequest(c), f = {}, f[c.name] = b, a.ajax(a.extend(!0, { url: d, mode: "abort", port: "validate" + c.name, dataType: "json", data: f, context: e.currentForm, success: function (d) { var f, h, i, j = d === !0 || "true" === d; e.settings.messages[c.name].remote = g.originalMessage, j ? (i = e.formSubmitted, e.prepareElement(c), e.formSubmitted = i, e.successList.push(c), delete e.invalid[c.name], e.showErrors()) : (f = {}, h = d || e.defaultMessage(c, "remote"), f[c.name] = g.message = a.isFunction(h) ? h(b) : h, e.invalid[c.name] = !0, e.showErrors(f)), g.valid = j, e.stopRequest(c, j) } }, d)), "pending") } } }), a.format = function () { throw "$.format has been deprecated. Please use $.validator.format instead." } }(jQuery), function (a) { var b, c = {}; a.ajaxPrefilter ? a.ajaxPrefilter(function (a, b, d) { var e = a.port; "abort" === a.mode && (c[e] && c[e].abort(), c[e] = d) }) : (b = a.ajax, a.ajax = function (d) { var e = ("mode" in d ? d : a.ajaxSettings).mode, f = ("port" in d ? d : a.ajaxSettings).port; return "abort" === e ? (c[f] && c[f].abort(), c[f] = b.apply(this, arguments), c[f]) : b.apply(this, arguments) }) }(jQuery), function (a) { a.extend(a.fn, { validateDelegate: function (b, c, d) { return this.bind(c, function (c) { var e = a(c.target); return e.is(b) ? d.apply(e, arguments) : void 0 }) } }) }(jQuery);;
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /* jshint strict: false */

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else {
        Q = definition();
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you donât need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millerâs explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become fulfilled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be fulfilled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If itâs a fulfilled promise, the fulfillment value is nearer.
 * If itâs a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return isObject(object) &&
        typeof object.promiseDispatch === "function" &&
        typeof object.inspect === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});
;
(function(n){n(["jquery"],function(n){return function(){function l(n,t,f){return u({type:r.error,iconClass:i().iconClasses.error,message:n,optionsOverride:f,title:t})}function a(n,t,f){return u({type:r.info,iconClass:i().iconClasses.info,message:n,optionsOverride:f,title:t})}function v(n){e=n}function y(n,t,f){return u({type:r.success,iconClass:i().iconClasses.success,message:n,optionsOverride:f,title:t})}function p(n,t,f){return u({type:r.warning,iconClass:i().iconClasses.warning,message:n,optionsOverride:f,title:t})}function w(r){var u=i();if(t||f(u),r&&n(":focus",r).length===0){r[u.hideMethod]({duration:u.hideDuration,easing:u.hideEasing,complete:function(){c(r)}});return}t.children().length&&t[u.hideMethod]({duration:u.hideDuration,easing:u.hideEasing,complete:function(){t.remove()}})}function b(){return{tapToDismiss:!0,toastClass:"toast",containerId:"toast-container",debug:!1,showMethod:"fadeIn",showDuration:300,showEasing:"swing",onShown:undefined,hideMethod:"fadeOut",hideDuration:1e3,hideEasing:"swing",onHidden:undefined,extendedTimeOut:1e3,iconClasses:{error:"toast-error",info:"toast-info",success:"toast-success",warning:"toast-warning"},iconClass:"toast-info",positionClass:"toast-top-right",timeOut:5e3,titleClass:"toast-title",messageClass:"toast-message",target:"body",closeHtml:"<button>&times;<\/button>",newestOnTop:!0}}function h(n){e&&e(n)}function u(r){function l(t){if(!n(":focus",e).length||t)return e[u.hideMethod]({duration:u.hideDuration,easing:u.hideEasing,complete:function(){c(e),u.onHidden&&u.onHidden(),s.state="hidden",s.endTime=new Date,h(s)}})}function b(){(u.timeOut>0||u.extendedTimeOut>0)&&(y=setTimeout(l,u.extendedTimeOut))}function k(){clearTimeout(y),e.stop(!0,!0)[u.showMethod]({duration:u.showDuration,easing:u.showEasing})}var u=i(),v=r.iconClass||u.iconClass;typeof r.optionsOverride!="undefined"&&(u=n.extend(u,r.optionsOverride),v=r.optionsOverride.iconClass||v),o++,t=f(u);var y=null,e=n("<div/>"),p=n("<div/>"),w=n("<div/>"),a=n(u.closeHtml),s={toastId:o,state:"visible",startTime:new Date,options:u,map:r};return r.iconClass&&e.addClass(u.toastClass).addClass(v),r.title&&(p.append(r.title).addClass(u.titleClass),e.append(p)),r.message&&(w.append(r.message).addClass(u.messageClass),e.append(w)),u.closeButton&&(a.addClass("toast-close-button"),e.prepend(a)),e.hide(),u.newestOnTop?t.prepend(e):t.append(e),e[u.showMethod]({duration:u.showDuration,easing:u.showEasing,complete:u.onShown}),u.timeOut>0&&(y=setTimeout(l,u.timeOut)),e.hover(k,b),!u.onclick&&u.tapToDismiss&&e.click(l),u.closeButton&&a&&a.click(function(n){n.stopPropagation(),l(!0)}),u.onclick&&e.click(function(){u.onclick(),l()}),h(s),u.debug&&console&&console.log(s),e}function f(r){return(r||(r=i()),t=n("#"+r.containerId),t.length)?t:(t=n("<div/>").attr("id",r.containerId).addClass(r.positionClass),t.appendTo(n(r.target)),t)}function i(){return n.extend({},b(),s.options)}function c(n){(t||(t=f()),n.is(":visible"))||(n.remove(),n=null,t.children().length===0&&t.remove())}var t,e,o=0,r={error:"error",info:"info",success:"success",warning:"warning"},s={clear:w,error:l,getContainer:f,info:a,options:{},subscribe:v,success:y,version:"2.0.1",warning:p};return s}()})})(typeof define=="function"&&define.amd?define:function(n,t){typeof module!="undefined"&&module.exports?module.exports=t(require(n[0])):window.toastr=t(window.jQuery)});
//@ sourceMappingURL=toastr.min.js.map;
/// <reference path="../jquery-2.0.3.intellisense.js" />

// Task		| By	| Date		| Modification Description
// ---------|-------|-----------|-------------------------
// 133003  	| RJR	| 11/21/13  | Created
// 133009   | RJR   | 11/25/13  | Updated to support numeric table fields.
// 133019   | RJR   | 12/02/13  | Updated to support strings w/ lists.
// 133951   | RJR   | 12/06/13  | Re-wrote to not do editing in the grid.
// 133801   | RJR   | 12/12/13  | Updated to support dates and date/time.
// 133813   | RJR   | 12/17/13  | Refactored to better namespace and only expose necessary public functions.
// 134705   | RJR   | 12/27/13  | Refactored w/ better jQuery performance practices.
// 134368   | MDL   | 01/16/14  | Added bindevent logic.
// 136463   | RJR   | 02/13/14  | Pass true for cache flag for filter attributes web service.
// 138153   | RJR   | 03/07/14  | Allow lists for number fields.
// 138302   | RJR   | 03/13/14  | Support wildcard searches.
// 134484   | TDA   | 03/14/14  | Set Width = 100% and set ControlType for combo
// 138675   | RJR   | 03/18/14  | Support default actions.
// 139475   | RJR   | 03/20/14  | Follow HTML5 standard of prefixing custom attributes with "data-".
// 139102   | RJR   | 03/26/14  | Don't enable add button if "filter condition" is cleared.
// 140060   | RJR   | 03/28/14  | Handle default action for combo boxes in advanced criteria.
// 140391   | RJR   | 05/05/14  | Added validation.
// 140391   | RJR   | 05/09/14  | Call filter attributes web service with query parameters.
// 141896   | SAM   | 05/14/14	| Added regionalsetting for editors
// 142815   | RJR   | 05/22/14  | Updated minimum date - javascript months are 0 based.
// 142950	| MDL	| 06/05/14	| use handlebar template.
// 145450	| SAM	| 08/12/14	| Applied Regional formatting before adding record to AdvancedCriteriaGrid.
// 144635   | TDA   | 08/29/14  | Added proper attributes for editor sizing
// 147206   | AA    | 09/18/14  | Renamed FieldDisplay, OperandDisplay and ValueDisplay to Field, Operand and Value respectivley to support toggling resource key by using correct resource key as a data attributes. The grid's resource data attributes are generated from client side using key value for the resource key.
// 147715   | RJR   | 09/24/14  | Workaround to enforce proper min date.
// 147507   | AA    | 09/22/14  | Renamed ConditionDisplay to Condition.
// 147514   | AA    | 09/25/14  | Modified setValueControlBackToDefault to set the editor control using the data-controltype not date editor as default.
// 149917   | AA    | 11/26/14  | Added disableSaveButton to disable the Add button on click of clear button in the value control. 
// 162246   | TDA   | 09/17/15  | Infragistics 2015.1 upgrade - igCombo changes
// 167433   | TDA   | 10/02/15  | Added enableClearButton back for IgniteUI SR 2300
// 185860   | RJR   | 08/29/16  | Modify advanced criteria to be loaded on the fly in modal dialog. 
// 167148   | TDA   | 11/29/16  | ig upgrade 2016.2
// 194553   | RJR   | 12/19/16  | Fixed value control being hidden after choosing is null or is not null. 
// 194555   | RJR   | 12/19/16  | Fixed some times when value isn't shown in grid when user presses enter key. 
// 195505   | RJR   | 01/09/17  | Made the save button not be enabled when it is a date/time control and nothing entered by user. 
// 195532   | RJR   | 01/10/17  | Fix input when user enters text manually into igDateEditor. 
// 198752   | RJR   | 02/16/17  | Fix date picker when user puts cursor in it and hits enter without entering anything. 
// 204139   | RJR   | 04/19/17  | Modified max date to be 1/1/9999 because of Infragistics issue.
// 205830   | RJR   | 06/06/17  | Support calendar drop down with manual time entry.
// 211400   | PA    | 08/04/17  | Combobox scrollbar not working when list has more items.
// 211749   | TDA   | 08/17/17  | Suppress keyboard for Value Dropdown
// 211889   | PA    | 08/18/17  | Display value control if required when operand value changes.
// 211749   | TDA   | 10/19/17  | Suppress keyboard for Date controls
// 212937   | TDA   | 12/19/17  | IG 2017.2
// 212937   | TDA   | 01/03/18  | Fixed $ig.regional calls
// 217488   | SO    | 01/09/18  | modified addToAdvancedCritGrid to differentiate date and datetime values.
// 217225   | TDA   | 01/12/18  | Remove the group separator for integer numbers
// 217544   | MHM   | 05/08/18  | Handle advance criteria for TPM screens.
// 220731   | TDA   | 05/25/18  | Handle dates properly for different language formats
// 217753   | SO    | 06/04/18  | Modified to display seconds in datefields
// 225385   | TDA   | 06/18/18  | Check variable before grabbing maxLength
// 249416   | MGK   | 04/02/20  | Added logic to handle date/datetime formats other than MM/DD/YYYY
// 249814   | MGK   | 04/13/20  | Default dateformat set to MM/dd/yyyy for valueIdentifier
// 253638   | SO    | 06/23/20  | Modified to set valueIdentifier in MM/dd/yyyy HH:mm:ss format, to prevent error when converting back to DateTime gives invalid date if its in other format when language is different than english
                                       // also this variable is used only for calculation not for display purpose.

_webUi.advancedCriteria = function () {
    // private variables
    var _controlNamePrefix;
    var _filterAttributeResponseData;
    var _currentValueControlType = "EDITOR";
    var _currentValueControlUsesTime = false;
    var _valueControlPlaceholderText;
    var _valueControlDateFormat;
    var _valueControlDateTimeFormat;
    var _comboDefaultActionsHaveBeenAdded = false;

    // private functions
    // convert filter attributes type to data type for json
    var convertFilterAttributesTypeToDataType = function (fieldType) {
        switch (fieldType) {

            case 'ALPHA':
                return "A";
            case 'NUMBER':
                return "I";
            case 'DECIMAL':
                return "N";
            case 'DATE':
                return "D";
            case 'DATETIME':
                return "D";
            default:
                return "";
        }
    };

    // enable/disable the operand control
    var enableOperandControl = function (enable) {
        var operandSelector = $("#" + _controlNamePrefix + "_Operand");
        operandSelector.igCombo("option", "disabled", !enable);
    };

    // enable/disable the value control
    var enableValueControlAndSaveButton = function (enable, ui) {
        // value control
        var valueSelector = $("#" + _controlNamePrefix + "_Value");
        if (_currentValueControlType === "COMBO")
            valueSelector.igCombo("option", "disabled", !enable);
        else if (_currentValueControlType === "DATEPICKER") {
            valueSelector.igDatePicker("option", "readOnly", !enable);
            valueSelector.igDatePicker("option", "disabled", !enable);
        }
        else if (_currentValueControlType === "DATEEDITOR") {
            valueSelector.igDateEditor("option", "readOnly", !enable);
            valueSelector.igDateEditor("option", "disabled", !enable);
        }
        else if (_currentValueControlType === "DECIMALEDITOR" ||
                 _currentValueControlType === "INTEDITOR") {
            valueSelector.igNumericEditor("option", "readOnly", !enable);
            valueSelector.igNumericEditor("option", "disabled", !enable);
        }
        else
            valueSelector.igTextEditor("option", "disabled", !enable);

        // save button
        if (enable) {
            var selectedFiltCondItems = $("#" + _controlNamePrefix + "_FilterCond").igCombo("selectedItems");
            var isFilterConditionSelected = (selectedFiltCondItems && selectedFiltCondItems.length > 0);
            var selectedFieldItems = $("#" + _controlNamePrefix + "_Field").igCombo("selectedItems");
            var isFieldSelected = (selectedFieldItems && selectedFieldItems.length > 0);
            var selectedOperandItems = $("#" + _controlNamePrefix + "_Operand").igCombo("selectedItems");
            var isOperandSelected = (selectedOperandItems && selectedOperandItems.length > 0);

            var isValueHidden = valueSelector.is(":hidden");
            var valueDisplay = "";
            if (_currentValueControlType == "COMBO") {
                var selectedItems = valueSelector.igCombo("selectedItems");
                if (selectedItems && selectedItems[0] && selectedItems[0].data)
                    valueDisplay = selectedItems[0].data.Identifier;
            }
            else if (_currentValueControlType == "DATEPICKER") {
                valueDisplay = valueSelector.igDatePicker("value");
                // for some reason if the user manually enters the text the "value" option is not returning it
                if (!valueDisplay && valueSelector.igDatePicker("field") && valueSelector.igDatePicker("field").length > 0) {
                    valueDisplay = valueSelector.igDatePicker("field")[0].value;
                    // if user enters nothing and event fires, IG returns something in the format __/__/____ which is equivalent to blank
                    if (valueDisplay) {
                        //if input still has '_' treat it as invalid
                        if (!valueDisplay.includes("_")) {
                            //this parses to correct value only when we have date in MM/DD/YYYY format or "Mon, 25 Dec 1995 13:30:00 GMT" but
                            //it doesn't parse when we have dd/mm/yyyy or dd.mm.yyyy formats
                            var date = Date.parse(valueDisplay);

                            if (isNaN(date)) {
                                //If we reached here then the date format is not in MM DD YYYY
                                let dateTimeParts = valueDisplay.split(' ');//split to get only date value
                                let dateParts = dateTimeParts[0].match(/\d+/g);//this returns array with day,month,year values
                                if (dateParts && dateParts.length > 2)
                                    date = Date.parse(new Date(dateParts[2], dateParts[1] - 1, dateParts[0]));
                                if (isNaN(date))
                                    valueDisplay = "";
                            }
                        }
                        else
                            valueDisplay = "";
                    }
                }
            }
            else if (_currentValueControlType == "DATEEDITOR") {
                valueDisplay = ui ? ui.text : valueSelector.igDateEditor("value");
                // if user enters nothing IG returns something in the format __/__/____ __:__ __ which is equivalent to blank
                if (valueDisplay) {
                    var date = Date.parse(valueDisplay);
                    if (isNaN(date))
                        valueDisplay = "";
                }
            }
            else if (_currentValueControlType == "DECIMALEDITOR" ||
                     _currentValueControlType == "INTEDITOR") {
                valueDisplay = ui ? ui.text : valueSelector.igNumericEditor("value");
            }
            else {
                valueDisplay = ui ? ui.text : valueSelector.igTextEditor("value");
            }

            if (isFilterConditionSelected && isFieldSelected && isOperandSelected && (valueDisplay || isValueHidden)) {
                disableSaveButton(false);

                // bind "default action" for first combos since it is not working from server side
                if (!_comboDefaultActionsHaveBeenAdded) {
                    _comboDefaultActionsHaveBeenAdded = true;

                    var fieldSelector = $("#" + _controlNamePrefix + "_Field");
                    var comboObjField = fieldSelector.data("igCombo");
                    var comboObjFldHandlers = fieldSelector.data("igCombo")._handlers;
                    var comboInputField = comboObjField.element;
                    comboInputField.off(comboObjFldHandlers); // unbind combo events
                    comboInputField.on("keydown", function (e) { return _webUi.onKeyPress(e, "SearchPaneAdvCrit_SaveButton"); }); // bind keydown event
                    comboInputField.on(comboObjFldHandlers); // rebind combo events

                    var opSelector = $("#" + _controlNamePrefix + "_Operand");
                    var comboObjOp = opSelector.data("igCombo");
                    var comboObjOpHandlers = opSelector.data("igCombo")._handlers;
                    var comboInputOp = comboObjOp.element;
                    comboInputOp.off(comboObjOpHandlers); // unbind combo events
                    comboInputOp.on("keydown", function (e) { return _webUi.onKeyPress(e, "SearchPaneAdvCrit_SaveButton"); }); // bind keydown event
                    comboInputOp.on(comboObjOpHandlers); // rebind combo events
                }
            }
            else {
                disableSaveButton(true);
            }
        }
        else {
            disableSaveButton(true);
        }
    };

    // failure callback from filter attributes web service call
    var filterAttributesFailureCallback = function (responseData) {
        _filterAttributeResponseData = null;
        setOperandCombo(null);
        setValueControl(null);

        // disable controls
        enableOperandControl(false);
        enableValueControlAndSaveButton(false);
    };

    // success callback from filter attributes web service call
    var filterAttributesSuccessCallback = function (responseData) {
        _filterAttributeResponseData = responseData;

        // enable operand control
        enableOperandControl(true);

        setOperandCombo(responseData.OperandList);
        setValueControl(responseData.FieldType, responseData.AttributeList);
    };

    // putting this is separate function so it can be called from setTimeout
    var addToAdvancedCritGrid = function () {
        $("#" + _controlNamePrefix + "_SaveButton").focus();

        var filterCondSelector = $("#" + _controlNamePrefix + "_FilterCond");
        var fieldSelector = $("#" + _controlNamePrefix + "_Field");
        var operandSelector = $("#" + _controlNamePrefix + "_Operand");
        var valueSelector = $("#" + _controlNamePrefix + "_Value");

        var filterCondIdentifier = filterCondSelector.igCombo("selectedItems")[0].data.Identifier;
        var filterCondDisplay = filterCondSelector.igCombo("selectedItems")[0].data.DisplayText;
        var fieldIdentifier = fieldSelector.igCombo("selectedItems")[0].data.Identifier;
        var fieldDisplay = fieldSelector.igCombo("selectedItems")[0].data.DisplayText;
        var operandIdentifier = operandSelector.igCombo("selectedItems")[0].data.Identifier;
        var operandDisplay = operandSelector.igCombo("selectedItems")[0].data.DisplayText;
        var dataType = valueSelector.attr("data-dataType");

        if (dataType == "D") {
            if (_currentValueControlType == "DATEPICKER" && !_currentValueControlUsesTime )
                dataType = "D";
            else
                dataType = "DT";
        }

        var valueIdentifier = "";
        var valueDisplay = "";
        if (_currentValueControlType == "COMBO") {
            var selectedItems = valueSelector.igCombo("selectedItems");
            if (selectedItems) {
                valueIdentifier = selectedItems[0].data.Identifier;
                valueDisplay = selectedItems[0].data.DisplayText;
            }
        }
        else if (_currentValueControlType == "DATEPICKER") {
            var dateValue = valueSelector.igDatePicker("option", "value");
            if (dateValue) {
                if (_currentValueControlUsesTime) {
                    if ($.ig.regional[_webUi.getUserRegionalSetting()]) {                        
                        valueDisplay = $.ig.formatter(dateValue, "dateTime", $.ig.regional[_webUi.getUserRegionalSetting()].datePattern + " " + $.ig.regional[_webUi.getUserRegionalSetting()].timeLongPattern);
                    }
                    else {
                        valueDisplay = $.ig.formatter(dateValue, "dateTime", $.ig.regional.defaults.datePattern + " " + $.ig.regional.defaults.timeLongPattern);
                    }
                    //always format date to MM/dd/yyyy because this was only working for format(MM/dd/yyyy) but was failing for formats like 'dd.MM.yyyy hh:mm:ss' in insightSearchPaneActions.js while converting to ISOString()
                    valueIdentifier = $.ig.formatter(dateValue, "dateTime", "MM/dd/yyyy" + " " + "HH:mm:ss");
                }
                else {
                    //specified MM/dd/yyyy format because formatter method was returning 24/04/2019(example date having day>12) instead of 04/24/2019 when regional format is dd/mm/yyyy 
                    //and 24/04/2019 would be passed to backend and will fail in SQL query 
                        valueIdentifier = $.ig.formatter(dateValue, "date", "MM/dd/yyyy");

                        if ($.ig.regional[_webUi.getUserRegionalSetting()])
                            valueDisplay = $.ig.formatter(dateValue, "date", $.ig.regional[_webUi.getUserRegionalSetting()].datePattern);
else
                            valueDisplay = $.ig.formatter(dateValue, "date", $.ig.regional.defaults.datePattern);
                }
            }
        }
        else if (_currentValueControlType == "DATEEDITOR") {
            var dateTimeValue = valueSelector.igDateEditor("option", "value");
            if (dateTimeValue) {              

                if ($.ig.regional[_webUi.getUserRegionalSetting()]) {
                    valueDisplay = $.ig.formatter(dateTimeValue, "dateTime", $.ig.regional[_webUi.getUserRegionalSetting()].datePattern + " " + $.ig.regional[_webUi.getUserRegionalSetting()].timeLongPattern);
                }
                else {
                    valueDisplay = $.ig.formatter(dateTimeValue, "dateTime", $.ig.regional.defaults.datePattern + " " + $.ig.regional.defaults.timeLongPattern);
                }
                valueIdentifier = $.ig.formatter(dateValue, "dateTime", "MM/dd/yyyy" + " " + "HH:mm:ss");
            }
        }
        else if (_currentValueControlType == "DECIMALEDITOR") {
            valueIdentifier = valueSelector.igNumericEditor("value");
            valueDisplay = $.ig.formatter(valueSelector.igNumericEditor("value"));
        }
        else if (_currentValueControlType == "INTEDITOR") {
            valueIdentifier = valueSelector.igNumericEditor("value");
            valueDisplay = $.ig.formatter(valueSelector.igNumericEditor("value"));
            valueDisplay = valueDisplay.toString().replace($.ig.regional.defaults.numericGroupSeparator, '');
        }
        else {
            valueIdentifier = valueSelector.igTextEditor("option", "value");
            valueDisplay = valueSelector.igTextEditor("option", "value");
        }

        // fill grid
        var gridSelector = $("#" + _controlNamePrefix + "AdvCritGrid");

        gridSelector.igGridUpdating('addRow', {
            'ConditionIdentifier': filterCondIdentifier,
            'Condition': filterCondDisplay,
            'FieldIdentifier': fieldIdentifier,
            'Field': fieldDisplay,
            'OperandIdentifier': operandIdentifier,
            'Operand': operandDisplay,
            'ValueIdentifier': valueIdentifier,
            'Value': valueDisplay,
            'DataType': dataType,
            'PrimaryKey': _webUi.createGuid()
        });

        // reset top section
        setBackToDefault();
    };

    // hide the value control
    var hideValueControl = function () {
        var valueSelector = $("#" + _controlNamePrefix + "_Value");
        if (_currentValueControlType == "COMBO") {
            valueSelector.igCombo("clearInput");
        }
        else if (_currentValueControlType == "DATEPICKER") {
            valueSelector.igDatePicker("option", "value", null);
        }
        else if (_currentValueControlType == "DATEEDITOR") {
            valueSelector.igDateEditor("option", "value", null);
        }
        else if (_currentValueControlType == "DECIMALEDITOR" ||
                 _currentValueControlType == "INTEDITOR") {
            valueSelector.igNumericEditor("option", "value", null);
        }
        else {
            valueSelector.igTextEditor("option", "value", null);
        }


        $(".AdvancedSearchCriteria_Value").hide();
    };

    // set the top section back to default
    var setBackToDefault = function () {
        // clear field and operand controls
        var fieldSelector = $("#" + _controlNamePrefix + "_Field");
        var operandSelector = $("#" + _controlNamePrefix + "_Operand");

        fieldSelector.igCombo("clearInput");
        operandSelector.igCombo("clearInput");

        // set "value" control back to default
        setValueControlBackToDefault(true);

        // disable fields
        enableOperandControl(false)
        enableValueControlAndSaveButton(false);

        // set focus
        fieldSelector.igCombo("textInput").focus();
    };

    //set the "operand" list 
    var setOperandCombo = function (operandList) {
        var operandSelector = $("#" + _controlNamePrefix + "_Operand");
        operandSelector.igCombo("clearInput");
        operandSelector.igCombo("option", "dataSource", operandList);
    };

    // set the "value" control type 
    var setValueControl = function () {
        // destroy existing controls
        var valueSelector = $("#" + _controlNamePrefix + "_Value");

        if (_currentValueControlType == "COMBO")
            valueSelector.igCombo("destroy");
        else if (_currentValueControlType == "DATEPICKER")
            valueSelector.igDatePicker("destroy");
        else if (_currentValueControlType == "DATEEDITOR")
            valueSelector.igDateEditor("destroy");
        else if (_currentValueControlType == "DECIMALEDITOR" ||
                 _currentValueControlType == "INTEDITOR")
            valueSelector.igNumericEditor("destroy");
        else
            valueSelector.igTextEditor("destroy");

        switch (_filterAttributeResponseData.FieldType) {

            case 'ALPHA':
            case 'NUMBER':

                valueSelector = $("#" + _controlNamePrefix + "_Value");

                if (_filterAttributeResponseData.AttributeList && _filterAttributeResponseData.AttributeList.length > 0) {
                    var isDescUsedAsDisplay = _filterAttributeResponseData.AttributeList[0].IsDescUsedForDisplay;
                    valueSelector.igCombo({
                        width: "100%",
                        //allowCustomValue: false,
                        compactData: false,
                        disabled: true,
                        height: 25,
                        enableClearButton: true,
                        filteringType: "local",
                        itemTemplate: "<div class='comboTemplate'>"
                            + "<div class='comboInfo'>"
                            + "<span class='emphasizedText'>{{DisplayText}}</span>"
                            + "<div><span class='deEmphasizedText'>"
                            + "{{" + (isDescUsedAsDisplay ? "Identifier" : "Description") + "}}</span></div></div></div>",
                        locale: { placeHolder: _valueControlPlaceholderText},
                        highlightMatchesMode: "multi",
                        textKey: "DisplayText",
                        valueKey: "Identifier",
                        visibleItemsCount: 10,
                        suppressKeyboard: true,
                        dataSource: _filterAttributeResponseData.AttributeList,
                    });

                    // tie selection changed and click event
                    valueSelector.igCombo({
                        selectionChanged: function (evt, ui) {
                            _webUi.advancedCriteria.valueControlSelectionChanged(evt, ui)
                        },
                        buttonClick: function (evt) {
                            disableSaveButton(true);
                        }
                    });

                    // bind "default action" for combo since it is different than other controls and doesn't work with universal binding
                    var comboObj = valueSelector.data("igCombo");
                    var comboObjHandlers = valueSelector.data("igCombo")._handlers;
                    var comboInput = comboObj.element;
                    comboInput.off(comboObjHandlers); // unbind combo events
                    comboInput.on("keydown", function (e) { return _webUi.onKeyPress(e, "SearchPaneAdvCrit_SaveButton"); }); // bind keydown event
                    comboInput.on(comboObjHandlers); // rebind combo events

                    valueSelector.attr("data-controlType", "igCombo");

                    _currentValueControlType = "COMBO";
                    _currentValueControlUsesTime = false;
                }
                else {
                    if (_filterAttributeResponseData.FieldType === 'ALPHA') {
                        valueSelector.igTextEditor({
                            buttonType: "clear",
                            height: 25,
                            width: "100%",
                            disabled: true,
                            readOnly: false,
                            maxLength: _filterAttributeResponseData.MaxLength,
                            locale: { placeHolder: _valueControlPlaceholderText },
                            regional: _webUi.getUserRegionalSetting,
                            revertIfNotValid: true,
                            selectionOnFocus: "selectAll",
                            supressNotifications: true
                        });

                        // tie text changed and click event
                        valueSelector.igTextEditor({
                            textChanged: function (evt, ui) {
                                _webUi.advancedCriteria.valueControlTextChanged(evt, ui);
                                _webUi.editors.textEditorTextChanged(evt, ui);
                            },
                            buttonClick: function (evt) {
                                disableSaveButton(true);
                            }
                        });

                        valueSelector.attr("data-defaultAction", _controlNamePrefix + "_SaveButton");
                        valueSelector.attr("data-controlType", "igTextEditor");

                        _currentValueControlType = "TEXTEDITOR";
                        _currentValueControlUsesTime = false;
                    }
                    else if (_filterAttributeResponseData.FieldType === 'NUMBER') {
                        valueSelector.igNumericEditor({
                            buttonType: "clear",
                            dataMode: "int",
                            height: 25,
                            width: "100%",
                            disabled: true,
                            groupSeparator: '',
                            maxDecimals: 0,
                            maxValue: _webUi.getMaxValueBasedOnResourceFile(_filterAttributeResponseData.MaxLength, 0),
                            minDecimals: 0,
                            locale: { placeHolder: _valueControlPlaceholderText },
                            regional: _webUi.getUserRegionalSetting(),
                            revertIfNotValid: true,
                            selectionOnFocus: "selectAll",
                            suppressNotifications: true,
                            textAlign: "left"
                        });

                        // tie text changed and click event
                        valueSelector.igNumericEditor({
                            textChanged: function (evt, ui) {
                                _webUi.advancedCriteria.valueControlTextChanged(evt, ui);
                                _webUi.editors.numericEditorTextChanged(evt, ui);
                            },
                            buttonClick: function (evt) {
                                disableSaveButton(true);
                            }
                        });

                        valueSelector.attr("data-defaultAction", _controlNamePrefix + "_SaveButton");
                        valueSelector.attr("data-controlType", "igNumericEditor");

                        _currentValueControlType = "INTEDITOR";
                        _currentValueControlUsesTime = false;
                    }
                }

                break;
            case 'DECIMAL':
                valueSelector.igNumericEditor({
                    buttonType: "clear",
                    dataMode: "double",
                    height: 25,
                    width: "100%",
                    disabled: true,
                    groupSeparator: '',
                    maxDecimals: _filterAttributeResponseData.DecimalPositions,
                    maxValue: _webUi.getMaxValueBasedOnResourceFile(_filterAttributeResponseData.MaxLength, _filterAttributeResponseData.DecimalPositions),
                    minDecimals: _filterAttributeResponseData.DecimalPositions,
                    locale: { placeHolder: _valueControlPlaceholderText },
                    regional: _webUi.getUserRegionalSetting(),
                    revertIfNotValid: true,
                    selectionOnFocus: "selectAll",
                    suppressNotifications: true,
                    textAlign: "left",
                    validation: true
                });

                // tie text changed and click event
                valueSelector.igNumericEditor({
                    textChanged: function (evt, ui) {
                        _webUi.advancedCriteria.valueControlTextChanged(evt, ui);
                        _webUi.editors.numericEditorTextChanged(evt, ui);
                    },
                    buttonClick: function (evt) {
                        disableSaveButton(true);
                    }
                });

                valueSelector.attr("data-defaultAction", _controlNamePrefix + "_SaveButton");
                valueSelector.attr("data-controlType", "igNumericEditor");

                _currentValueControlType = "DECIMALEDITOR";
                _currentValueControlUsesTime = false;
                break;
            case 'DATE':
                valueSelector.igDatePicker({
                    buttonType: "clear",
                    height: 25,
                    width: "100%",
                    dataMode: "date",
                    dateDisplayFormat: _valueControlDateFormat,
                    dateInputFormat: _valueControlDateFormat,
                    disabled: true,
                    maxValue: new Date(9999, 0, 1),
                    minValue: new Date(1753, 0, 1),
                    locale: { placeHolder: _valueControlPlaceholderText },
                    regional: _webUi.getUserRegionalSetting(),
                    revertIfNotValid: true,
                    selectionOnFocus: "selectAll",
                    suppressKeyboard: true,
                    suppressNotifications: true,
                });

                // tie text changed and click event
                valueSelector.igDatePicker({
                    textChanged: function (evt, ui) {
                        _webUi.advancedCriteria.valueControlTextChanged(evt, ui);
                        _webUi.editors.datePickerTextChanged(evt, ui);
                    },
                    buttonClick: function (evt) {
                        disableSaveButton(true);
                    }
                });

                valueSelector.attr("data-defaultAction", _controlNamePrefix + "_SaveButton");
                valueSelector.attr("data-controlType", "igDatePicker");

                _currentValueControlType = "DATEPICKER";
                _currentValueControlUsesTime = false;
                break;
            case 'DATETIME':

               
                valueSelector.igDatePicker({
                    buttonType: "clear",
                    height: 25,
                    width: "100%",
                    dataMode: "date",
                    dateDisplayFormat: _valueControlDateTimeFormat,
                    dateInputFormat: _valueControlDateTimeFormat,
                    disabled: true,
                    maxValue: new Date(9999, 0, 1),
                    minValue: new Date(1753, 0, 1),
                    locale: { placeHolder: _valueControlPlaceholderText },
                    regional: _webUi.getUserRegionalSetting(),
                    revertIfNotValid: true,
                    selectionOnFocus: "selectAll",
                    suppressKeyboard: true,
                    suppressNotifications: true,

                });

                // tie text changed and click event
                valueSelector.igDatePicker({
                    textChanged: function (evt, ui) {
                        _webUi.advancedCriteria.valueControlTextChanged(evt, ui);
                        _webUi.editors.datePickerTextChanged(evt, ui);
                    },
                    buttonClick: function (evt) {
                        disableSaveButton(true);
                    }
                });

                valueSelector.attr("data-defaultAction", _controlNamePrefix + "_SaveButton");
                valueSelector.attr("data-controlType", "igDatePicker");

                _currentValueControlType = "DATEPICKER";
                _currentValueControlUsesTime = true;
                break;
            default:
                setValueControlBackToDefault(false);
                break;
        }

        // tie dataType attribute to control
        valueSelector.attr("data-dataType", convertFilterAttributesTypeToDataType(_filterAttributeResponseData.FieldType));
    };

    // set the "value" control type back to default
    var setValueControlBackToDefault = function (destroy) {
        // destroy existing controls
        var valueSelector = $("#" + _controlNamePrefix + "_Value");

        if (destroy) {
            if (_currentValueControlType == "COMBO") {
                valueSelector.igCombo("clearInput"); // puts into new editor if we don't clear this
                valueSelector.igCombo("destroy");
            }
            else if (_currentValueControlType == "DATEPICKER")
                valueSelector.igDatePicker("destroy");
            else if (_currentValueControlType == "DATEEDITOR")
                valueSelector.igDateEditor("destroy");
            else if (_currentValueControlType == "DECIMALEDITOR" ||
                     _currentValueControlType == "INTEDITOR")
                valueSelector.igNumericEditor("destroy");
            else
                valueSelector.igTextEditor("destroy");
        }

        var maxLength;

        if (_filterAttributeResponseData && _filterAttributeResponseData.MaxLength)
            maxLength = _filterAttributeResponseData.MaxLength;
        
        valueSelector.igTextEditor({
            buttonType: "clear",
            height: 25,
            width: "100%",
            disabled: true,
            readOnly: false,
            maxLength: maxLength,
            locale: { placeHolder: _valueControlPlaceholderText },
            regional: _webUi.getUserRegionalSetting,
            revertIfNotValid: true,
            selectionOnFocus: "selectAll",
            suppressNotifications: true
        });

        // tie text changed and click event
        valueSelector.igTextEditor({
            textChanged: function (evt, ui) {
                _webUi.advancedCriteria.valueControlTextChanged(evt, ui);
                _webUi.editors.textEditorTextChanged(evt, ui);
            },
            buttonClick: function (evt) {
                disableSaveButton(true);
            }
        });


        valueSelector.attr("data-defaultAction", _controlNamePrefix + "_SaveButton");
        valueSelector.attr("data-controlType", "igTextEditor");
        _currentValueControlType = "TEXTEDITOR";
        _currentValueControlUsesTime = false;
        $(".AdvancedSearchCriteria_Value").show();
    };

    // show the value control
    var showValueControl = function () {
        $("#" + _controlNamePrefix + "_Value").show();
        $(".AdvancedSearchCriteria_Value").show();
    };

    // disable save button
    var disableSaveButton = function (disable) {
        $("#" + _controlNamePrefix + "_SaveButton").prop("disabled", disable);
    };

    // public functions
    return {
        // add record to grid when save button is clicked 
        addRecordToAdvancedCriteriaGrid: function (evt) {
            _controlNamePrefix = evt.data.advCritName;
            
            // setTimeout is required because of IE
            setTimeout(function () { addToAdvancedCritGrid(); }, 1);
        },

        // call modal for advanced criteria
        callAdvancedCriteriaModal: function (evt) {
            if (evt && evt.data && evt.data.screenControlObjectId && $('#AdvancedCriteriaModalDiv').html().length === 0) {
                var path;
                var pathArray = window.location.pathname.split('/');
                if (pathArray[1].toLowerCase() === "tpm")
                    path = "/tpm/insight/renderPartial/";
                else
                    path = "/scale/insight/renderPartial/";

                $('#AdvancedCriteriaModalDiv').load(path + evt.data.screenControlObjectId + '?url=~/Views/Insight/_AdvancedCriteriaPartial.cshtml',
                    function () {
                        _webUi.dialog.showModalDialog("#AdvancedCriteriaModal", _webUi.advancedCriteria.onAdvancedCriteriaModalHidden);
                    });
            }
            else {
                _webUi.dialog.showModalDialog("#AdvancedCriteriaModal", _webUi.advancedCriteria.onAdvancedCriteriaModalHidden)
            }
        },

        onAdvancedCriteriaModalHidden: function (evt) {
            setBackToDefault();
        },

        // field control "selectionChanged" event
        fieldControlSelectionChanged: function (evt, ui) {
            _valueControlPlaceholderText = evt.data.nullText;
            _valueControlDateFormat = evt.data.dateFormat;
            _valueControlDateTimeFormat = evt.data.dateTimeFormat;

            var advCritName = evt.data.advCritName;
            var selectedItems = ui.items;
            if (selectedItems && selectedItems[0] && selectedItems[0].data) {
                var selectedItem = selectedItems[0].data.Identifier;

                // user may be switching from one advanced filter section to another - if they are, clean up the previous section
                if (_controlNamePrefix && advCritName != _controlNamePrefix) {
                    setBackToDefault();
                }
                _controlNamePrefix = advCritName;

                var querystringData = new Object();
                querystringData["filterAttribute"] = _webUi.removeUnderscores(selectedItem);

                // call filter attributes web service
                _httpRequest.performGet("/general/scaleapi/FilterAttributesApi?" + $.param(querystringData),
                    filterAttributesSuccessCallback, filterAttributesFailureCallback, true, false);
            }
            else {
                setBackToDefault();
            }
        },

        // filter condition control "selectionChanged" event
        filterConditionControlSelectionChanged: function (evt, ui) {
            enableValueControlAndSaveButton(true);
        },

        // operand control "selectionChanged" event
        operandControlSelectionChanged: function (evt, ui) {
            var selectedItems = ui.items;
            if (selectedItems && selectedItems[0] && selectedItems[0].data) {
                var selectedItem = selectedItems[0].data.Identifier;

                // if "is null" or "is not null" selected, hide the value control; otherwise show it
                if (selectedItem == "90" || selectedItem == "100") {
                    hideValueControl();

                    // enable value control
                    enableValueControlAndSaveButton(true);
                }
                else {
                    showValueControl();

                    // if "contains" or "does not contain" selected, reset value control to default control
                    if (selectedItem == "70" || selectedItem == "80") {
                        setValueControlBackToDefault(true);

                        // enable value control
                        enableValueControlAndSaveButton(true);
                    }
                    else if (_filterAttributeResponseData) {
                        setValueControl();

                        // enable value control
                        enableValueControlAndSaveButton(true);
                    }
                    else
                        setValueControlBackToDefault(true);
                }
            }
            else {
                // show the value control and don't allow custom values
                showValueControl();

                // disable value control
                enableValueControlAndSaveButton(false);
            }
        },

        // value control "selectionChanged" event
        valueControlSelectionChanged: function (evt, ui) {
            enableValueControlAndSaveButton(true, ui);
        },

        // value control "textChanged" event
        valueControlTextChanged: function (evt, ui) {
            enableValueControlAndSaveButton(true, ui);
        }
    }
}();;
/// <reference path="../jquery-2.0.3.intellisense.js" />

// Task		| By	| Date		    | Modification Description
// ---------|-------|---------------|-------------------------
// 133017	| MDL	| 02/03/14	    | detail pane logic.
// 136002   | TDA   | 02/24/14      | called bindLabel
// 136304   | MDL   | 03/05/14      | HierarchicalGrid map header text for mutiple columns.
// 138325   | AA    | 03/11/14      | Modified inventoryInsightUMComboSelectionChanged() to show the lowest UM first.
// 138099   | MDL   | 03/10/14      | Remove expand call and added detailPaneModel.
// 137850   | MDL   | 03/16/14      | Added Address & empty model logic.
// 139475   | RJR   | 03/20/14      | Follow HTML5 standard of prefixing custom attributes with "data-".
// 139211   | MDL   | 03/25/14      | Check for undefined before binding.
// 138702   | TDA   | 03/27/14      | Added BindImage
// 138992   | TDA   | 04/04/14      | Added tooltips to mini and hierarchical grids
// 138905   | AA    | 04/14/14	    | Added grid row selection.
// 140148   | MDL   | 04/21/14      | Added vertical mini grid.
// 140152   | MDL   | 04/21/14      | Added windowWidthToRenderVertically to vertical grid.
// 141512   | RJR   | 04/24/14      | Temporary fix for horizontal scrollbar hiding last row in vertical grid issue.
// 140260   | AA    | 04/24/14	    | Added grid row selection.
// 140261   | AA    | 05/02/14      | Modifed to HierarchicalHeaderText to enable hidding of column in Hierarchica grid.
// 141185   | SP    | 05/12/14      | Enable Paging on mini grid and Hierarchical mini grid
// 141896   | SAM   | 05/14/14      | Added autoformat to the grids
// 138907   | MMM   | 05/19/14      | Added logic to set template value for HierarchicalGrid column header objects
// 138369   | TDA   | 05/21/14      | Removed tooltips
// 142905   | MMM   | 05/22/14      | Avoided showing empty grid's when no data exists
// 142138   | MMM   | 05/26/14      | Cleared previously rendered igHierarchicalGrid when no corresponding detail pane data exists for newly selected list pane record
// 143227   | TDA   | 05/28/14      | Removed setting height on vertical grid
// 142573   | MMM   | 06/03/14      | Fixed issue in hierarchical grid headerText processing logic
// 142950	| MDL	| 06/03/14	    | Added handlebar support.
// 143592   | MDL   | 06/06/14      | undo code changes of bug 142138
// 143585   | MMM   | 06/07/14      | Added paging feature for vertical minigrid. Pager is shown only when data row count exceeds page size ( fixed 143692)
// 145722   | AA    | 08/22/14      | Added a logic to add data- attributes to the detail pane for supporting resource key/value based on the toggle state on row select.
// 142257   | AA    | 09/08/14      | Added applyHeaderFormat method to support decimal format.
// 144816   | MMM   | 09/09/14      | Added logic to support data bind for link button control
// 157279   | MJ    | 03/25/15      | Refactored bindHierarchicalGrid() and updateHeaderText() to manh.ui.miniGrid.js 
// 159474   | MJ    | 03/25/15      | Rolled back refactoring.
// 157354   | SP    | 04/14/15      | Fixed bindData not to call ShowResourceValue when the screen is already showing resource value. This was causing the Resource text 
//                                      to be badly replaced when key is a substring of resource text
// 158738   | NRJ   | 06/23/15      | Modified updateHeaderText such that header template will be applied on the child grid.
// 163549   | MDL   | 07/22/15      | remove refresh to keep accordions open on ajax data populate.

// 143032   | MDL   | 08/13/14      | Added new function to check isDetailPaneStillLoading.
// 166528	| NRJ	| 09/16/15	    | Added support to invoke webservice in bindData method.
// 162246   | TDA   | 09/17/15      | Infragistics 2015.1 upgrade - igCombo changes
// 167433   | TDA   | 10/02/15      | Added enableClearButton back for IgniteUI SR 2300
// 168447   | TDA   | 10/21/15      | Do not select value in combo if the nodeData is empty
// 168493   | TDA   | 10/27/15      | Destroy the combo before loading it to ensure selection is done correctly
// 173708   | RJR   | 02/05/16      | Don't allow client side control to process UTC dates.
// 173020   | TDA   | 02/25/16      | Do not alternate row styles on grid
// 178089   | NRJ   | 05/23/16      | Added resizing feature to the miniGrid.
// 178091   | DP    | 05/24/16      | Added hiding feature to the miniGrid.
// 177825   | NRJ   | 05/25/16      | Added sorting feature to the miniGrid.
// 178090   | DP    | 05/27/16      | Added column moving feature to the miniGrid.
// 178092   | NRJ   | 06/02/16      | Added storing customizations to the miniGrid.
// 178619   | DP    | 06/06/16      | Added column resizing feature to the hierarchical minigrid.
// 178622   | DP    | 06/07/16      | Added column sorting feature to the hierarchical minigrid.
// 178621   | NRJ   | 06/09/16      | Added column moving feature.
// 178620   | DP    | 06/14/16      | Added column hiding feature to the hierarchical minigrid.
// 178623   | NRJ   | 06/13/16      | Modified hierarchical grid for storing customizations.
// 185233   | SP    | 08/16/16      | Remove the "show x records" from grid
// 186799   | RJR   | 09/23/16      | Support insight indicator tiles.
// 189223   | RJR   | 10/20/16      | Fix tiles when no rows are selected in the grid.
// 197158   | TDA   | 04/11/17      | Styled disabled indicator tiles
// 212937   | TDA   | 12/19/17      | IG 2017.2
// 219057   | TDA   | 06/01/18      | Properly disable indicator tiles
// 244822   | TDA   | 01/23/20      | Added Databound function for sorting
// 248145	| TDA	| 03/11/20		| Fixed calling of gridRowChangedEvent

_webUi.detailPane = function () {
    var hGridColumnHiddenComplete={};
	var _gridRowChangedEvent = null;

    var bindMiniGrid = function (node, nodeData, Headertext) {
        var $table = $("#" + node);
    	if ($table.data("igGrid") != null) {
    		$table.igGrid('destroy');
    	}
    	
        //Create grid only if data exists
    	if (nodeData.length > 0 && !$.isEmptyObject(nodeData[0])) {

    	    $table.igGrid({
    	        featureChooserIconDisplay: "desktopOnly"
    	    });

    	    $table.igGrid({
    	    alternateRowStyles: false,
    	    autoFormat: "dateandnumber",
    	    rendering: function (evt, ui) { _webUi.Grid.gridrendering(evt, ui) },
    	    rendered: function(evt,ui){_webUi.Grid.modalDialogOpened(evt,ui)},
            features: [
                {
                    name: 'Hiding',                    
                    columnHidden: function (evt, ui) { _webUi.Grid.gridColumnHidden(evt, ui) },
                    columnShown: function (evt, ui) { _webUi.Grid.gridColumnShown(evt, ui) }
                },
                {
                    name: 'Sorting',
                    type: 'local',
                    mode: 'multiple',                    
                },
                {
                    name: 'ColumnMoving',
                    columnMoved: function (evt, ui) { _webUi.Grid.gridColumnMoved(evt, ui) }
                },                
                {
                    name: 'Selection',
                    mode: 'row',
                    multipleSelection: false
    			},
    			{
    			    name: 'Paging',
    			    type: 'local',
    			    pageSize: 10,
    			    showPageSizeDropDown: false
                },                
                {
                    name: 'Resizing',
                    allowDoubleClickToResize: true,
                    columnResized: function (evt, ui) { _webUi.Grid.gridColumnSizeChanged(evt, ui) }
                }
            ],
            dataSource: nodeData,
            dataBound: function (evt, ui) { _webUi.Grid.gridDataBound(evt, ui) }
    	    }).igGrid("renderMultiColumnHeader", Headertext);
    	}
    };

   
    var bindVerticalMiniGrid = function (node, nodeData, Headertext) {
        var $table = $("#" + node);

        //Clear igGrid if already exists and we are trying to bind empty datasource
        if ($table.data("igGrid") != null && $.isEmptyObject(nodeData[0]))
            $table.igGrid("destroy");

        //Create grid only if data exists
        if (nodeData.length > 0 && !$.isEmptyObject(nodeData[0])) {
            $table.igGrid({
                autoFormat: "dateandnumber",
                enableUTCDates: false, 
                features: [
                    {
                        name: "Responsive",
                        enableVerticalRendering: true,
                        reactOnContainerWidthChanges: true,
                        windowWidthToRenderVertically: 3000
                    },
                    {
                        name: "Paging",
                        type: 'local',
                        pageSize: 1,
                        showPageSizeDropDown: false
                    }
                ],
                dataSource: nodeData

            }).igGrid("renderMultiColumnHeader", Headertext);

            if (!gridPagerRequired($table))
                hideGridPager(node);
        }

       
    };

    var bindTemplate = function (node, nodeData) {
        var $table = $("#" + node);
        var template = Handlebars.compile($table.html());
        var html = template(nodeData[0]);
        $("#" + node + "Box").html(html);
    };

    var bindCombo = function (node, nodeData) {
        var $table = $("#" + node);

        $table.igCombo("destroy"); //destory the combo to ensure records are selected correctly

        $table.igCombo({
            dataSource: nodeData, //JSON Array defined above         
            textKey: "DisplayText",
            valueKey: "Identifier",
            mode: "editable",
            locale: { placeHolder: "" },
            enableClearButton: false,

            //TODO: Add back when IgniteUI 2015.2 is released
            //allowCustomValue: false,

            selectItemBySpaceKey: true
        });
        
        if (nodeData && nodeData.length > 0 && nodeData[0].Identifier) {
            $table.igCombo("index", 0, { focusCombo: false });
        }
    };
  
    var bindHierarchicalGrid = function (node, nodeData, Headertext) {
        var $table = $("#" + node);

        //Clear igHierarchicalGrid if already exists
        if ($table.data("igGrid") != null) {
            $table.igHierarchicalGrid('destroy');
        }

        _webUi.detailPane.detailPaneHeirarchicalGridHeader = Headertext;

        //Create grid only if data exists
        if (nodeData.length > 0 && !$.isEmptyObject(nodeData[0])) {           

            $table.igHierarchicalGrid({
                alternateRowStyles: false,
                autoFormat: "dateandnumber",
                rendering: function (evt, ui) { _webUi.Grid.gridrendering(evt, ui) },
                rendered: function (evt, ui) { _webUi.Grid.modalDialogOpened(evt, ui) },
                features: [                    
                    {
                        name: 'Resizing',
                        allowDoubleClickToResize: true,
                        inherit: true,
                        columnResized: function (evt, ui) { _webUi.Grid.gridColumnSizeChanged(evt, ui) }
                    },
                    {
                        name: 'Sorting',
                        type: 'local',
                        mode: 'multiple',
                        inherit: true,
                    },
                    {
                        name: 'Hiding',
                        inherit: true,
                        columnHidden: function (evt, ui) { _webUi.Grid.gridColumnHidden(evt, ui) },
                        columnShown: function (evt, ui) { _webUi.Grid.gridColumnShown(evt, ui) }
                    },
                    {
                        name: 'ColumnMoving',
                        inherit: true,
                        columnMoved: function (evt, ui) { _webUi.Grid.gridColumnMoved(evt, ui) }
                    },                    
                    {
                        name: "Selection",
                        mode: 'row',
                        multipleSelection: false
                    },
                    {
                	    name: "Paging",
                	    type: 'local',
                	    pageSize: 10,
                	    showPageSizeDropDown: false,
                	    inherit: true
                    }],

                childGridRendered:function (evt, ui) { _webUi.Grid.modalDialogOpened(evt, ui)},                
                dataSource: nodeData,
                dataBound: function (evt, ui) { _webUi.Grid.gridDataBound(evt, ui) },
                autoGenerateLayouts: true,
                headerRendering: function (evt, ui) {
                    _webUi.detailPane.applyHeaderFormat(ui.owner.options, _webUi.detailPane.detailPaneHeirarchicalGridHeader);
                }
            });

            $table.on("igchildgridcreating", _webUi.Grid.gridrendering);

            $table.off("igchildgridcreated");
            $table.on("igchildgridcreated", _webUi.detailPane.updateHeaderText);
            var headertextObject = Headertext;
            var columnName = $table.igGrid("headersTable").find('thead').find('span.ui-iggrid-headertext').html();

            if (headertextObject[columnName] != undefined) {

                $table.igGrid("headersTable").find('thead').find('span.ui-iggrid-headertext').each(function () {
                    var columnName = $(this).html();

                    if (headertextObject[columnName]) {
                        if (headertextObject[columnName].template != undefined) {
                            $table.igGrid("setColumnTemplate", columnName, headertextObject[columnName].template, true);
                        }

                        if (headertextObject[columnName].headerText != undefined && headertextObject[columnName].hidden == true) {
                            if (hGridColumnHiddenComplete[node + columnName] === undefined || hGridColumnHiddenComplete[node + columnName] !== false)
                                hGridColumnHiddenComplete[node + columnName] = false;
                            $table.igGrid("hideColumn", columnName,function(){
                                hGridColumnHiddenComplete[node + columnName] = true;
                            });
                        } else if (headertextObject[columnName].headerText != undefined) {
                            $(this).html(headertextObject[columnName].headerText)
                        }
                    }
                })
            }
        }

    };

    var bindCollection = function (node, nodeData, fullResponse) {

        // bind grid
        var $table = $("#" + node);
        if ($table.attr("data-controlType") == "igGrid") {

            bindMiniGrid(node, nodeData, fullResponse[node + "Headertext"])
        }
        else if ($table.attr("data-controlType") == "VerticaligGrid") {

            bindVerticalMiniGrid(node, nodeData, fullResponse[node + "Headertext"])
        }
        else if ($table.attr("data-controlType") == "address" || $table.attr("data-controlType") == "userdefined") {
            bindTemplate(node, nodeData);
        }//bind HierarchicalGrid
        else if ($table.attr("data-controlType") == "igHierarchicalGrid") {
            bindHierarchicalGrid(node, nodeData, fullResponse[node + "Headertext"]);

        }
            //bind combo
        else if ($table.attr("data-controlType") == "igCombo") {
            bindCombo(node, nodeData);
        }
    };

    var createEmptyModel = function (ajaxData) {
        var emptyModel = {};
        emptyModel["ScalarData"] = new Array({});
        $.each(ajaxData, function (attributeName, attributeValue) {
            try {
                if (attributeValue.constructor == Array && attributeName.indexOf("ScalarData") >= 0 && attributeValue[0] != undefined) {
                    $.each(attributeValue[0], function (scalarAttributeName, scalarAttributeValue) {
                        emptyModel["ScalarData"][0][scalarAttributeName] = "";
                    });
                }
                else if (attributeValue.constructor == Array && !(attributeName.indexOf("Headertext") >= 0)) {
                    emptyModel[attributeName] = new Array({});
                }
                else if (attributeValue.constructor != Array && (typeof (attributeValue.indexOf) != 'undefined') && attributeValue.indexOf("image") >= 0) {
                    emptyModel[attributeName] = "image:";
                }
                else {
                    emptyModel[attributeName] = "";
                }
            }
            catch (error) {
                alert('Error in creating EmptyModel' + error);
            }
        });
        _webUi.detailPane.detailPaneEmptyModel = emptyModel;
    };

    var disableIndicatorTiles = function (data) {
        var controls = $("label[data-controlType$=LiveTile]");

        if(controls && controls.length > 0)
        {
            $.each(controls, function (index, value) {
                disableOrEnableIndicatorTile(data, value.getAttribute("data-bind").substring(6));
            });
        }
    }

    // sets the class on indicator tile to either show as enabled or disabled
    var disableOrEnableIndicatorTile = function (data, attributeName) {
        var tileValue;
        
        if(data)
            tileValue = data[attributeName];

        if (tileValue === undefined || tileValue === null || tileValue === "") {
            var tile = $("label[data-bind$=" + attributeName + "][data-controlType$=LiveTile]").parent();
            if (!tile.hasClass("disabledIndicatorTile"))
                tile.addClass("disabledIndicatorTile");
        }
        else {
            var tile = $("label[data-bind$=" + attributeName + "][data-controlType$=LiveTile]").parent();
            if (tile.hasClass("disabledIndicatorTile") && !tile.hasClass("noUrl"))
                tile.removeClass("disabledIndicatorTile");
        }
    }; 

    //Hides grid pager(header and footer)
    var hideGridPager = function (node) {

        var gridContainer = $("#" + node + "_container")

        if (gridContainer) {
            //Hide pager header
            gridContainer.find(".ui-iggrid-pagesizedropdowncontainerabove").hide();
            //Hide pager footer
            gridContainer.find("#" + node + "_pager").hide();
        }
    };

    var isLiveTile = function (attributeName) {
        var controls = $("label[data-bind$=" + attributeName + "][data-controlType$=LiveTile]");
        return (controls && controls.length > 0);
    };

    //Checks if grid pager required or not based on total number of records
    var gridPagerRequired = function (igGrid) {

        var pageSize = igGrid.igGridPaging("option", "pageSize");
        var ds = igGrid.igGrid("option", "dataSource");

        return (pageSize < ds.length);
    };

    // public functions
    return {

        detailPaneModel: null,
        detailPaneEmptyModel: null,
        detailPaneHeirarchicalGridHeader: null,

        // gridColumnSorted method called after sorting event
        inventoryInsightUMComboSelectionChanged: function (evt, ui) {
            if (ui !== undefined && (ui.items !== null && ui.items.length > 0 && ui.items[0].data && ui.items[0].data.Identifier)) {
                var selectedValue = ui.items[0].data.Identifier;
            }
            if (selectedValue !== undefined) {
                $.each(evt.data, function (index, value) {
                    var $labelControl = $("label[data-bind$=" + value.replace("$", "") + "]")
                    _webUi.label.bindLabel(value, $labelControl.attr("orignalValue") / selectedValue);

                });
            }
        },

        // return true if still loading otherwise false
        isDetailPaneStillLoading: function()
        {
            var isLoading = false;
            $.each(hGridColumnHiddenComplete, function (hGridIdAndColumnName, isColumnHiddenComplete) {
                if (isColumnHiddenComplete === false) {
                    isLoading = true;
                    return;
                }
            });
            return isLoading;
        },

        applyHeaderFormat: function (columns, headers) {
            $.each(headers, function (index, value) {
                if (columns.columns != undefined)
                    $.each(columns.columns, function (i, v) {
                        if (v.headerText == value.headerText && value.hasOwnProperty('format')) {
                            v.format = value.format;
                        }
                    });
            });
            if (columns.columnLayouts != undefined && columns.columnLayouts.length > 0) {
                _webUi.detailPane.applyHeaderFormat(columns.columnLayouts, headers);
            }
        },

        // success callback function to set label text based on data-bind attribute & grids
        bindData: function (data) {
            if (!data) {
                disableIndicatorTiles(data);
                return;
            }
            _webUi.detailPane.detailPaneModel = data;
            $.each(data, function (attributeName, attributeValue) {
                try {
                    if (attributeValue.constructor == Array && attributeName.indexOf("ScalarData") >= 0 && attributeValue[0] != undefined) {
                        $.each(attributeValue[0], function (scalarAttributeName, scalarAttributeValue) {
                            _webUi.label.bindLabel(scalarAttributeName, scalarAttributeValue);
                        });
                    }
                    else if (attributeValue.constructor == Array && attributeName.indexOf("WebService_") >= 0) {
                        var url = attributeValue[0]["WebServiceURL"];

                        delete attributeValue[0]["WebServiceURL"];
                        _httpRequest.performGet(url + $.param(attributeValue[0]), _webUi.MiniGrid.bindData, null, false, true);
                    }                    
                    else if (attributeValue.constructor == Array && !(attributeName.indexOf("Headertext") >= 0)) {
                        bindCollection(attributeName, attributeValue, data);
                    }
                    else if (!(attributeName.indexOf("Headertext") >= 0) && $("img[data-bind$=" + attributeName.replace("$", "") + "]").length == 1) {
                        _webUi.image.bindImage(attributeName, attributeValue);
                    }
                    else if (!(attributeName.indexOf("Headertext") >= 0)) {

                        //Check if control is a hyperlink
                        var isAnchor = false;
                        var controls = $("a[data-bind$=" + attributeName + "]");
                        if (controls && controls.length > 0)
                            isAnchor = true;

                        if (isAnchor) {
                            $.each(controls, function (index, control) {
                                _webUi.hyperlink.bindHyperlink(control.id, attributeValue, data);
                            });
                        }
                        else {
                            _webUi.label.bindOriginalValue(attributeName, attributeValue);
                            _webUi.label.bindLabel(attributeName, attributeValue);

                            if (isLiveTile(attributeName))
                                disableOrEnableIndicatorTile(data, attributeName);
                        }
                    }
                }
                catch (error) {
                    alert('Error in bindData' + error);
                }
            });

            if (_webUi.detailPane.detailPaneEmptyModel === null) {
                createEmptyModel(data);
            }

            //This adds the resource key data attributes to the detail pane grid to support resource key toggle. 
            _webUi.Grid.AddResourceDataAttributes();
            var resourceState = getCookie("resourceState");
            if (resourceState == "ON") {
                ShowResourceKey();
            } 

            //ensure focus stays in the grid area after binding
            $("[data-name=ListPaneDataGrid]").first().focus();

			//Invoke gridRowChangedEvent if it exists to allow for customizations to be processed
			if (_webUi.detailPane._gridRowChangedEvent !== undefined)
				_webUi.detailPane._gridRowChangedEvent();
        },

        updateHeaderText: function (evt, ui) {
            var customHeaderText = _webUi.detailPane.detailPaneModel[evt.currentTarget.id + "Headertext"];
            if (customHeaderText != undefined) {
                var customHeaderText = _webUi.detailPane.detailPaneModel[evt.currentTarget.id + "Headertext"];
                // var $firstRow = $("#" + evt.currentTarget.id).igHierarchicalGrid("allChildrenWidgets")[0].headersTable().find('span.ui-iggrid-headertext')
                ui.element.data("igGrid").headersTable().find('span.ui-iggrid-headertext').each(function () {                    
                    var columnName = $(this).html();
                    if (customHeaderText[columnName]) {
                        if (customHeaderText[columnName].headerText != undefined && customHeaderText[columnName].hidden == true) {
                            ui.element.igGrid("hideColumn", columnName);
                        } else if (customHeaderText[columnName].headerText != undefined) {
                            //adds the resource data attributes to support resource key toggle.
                            _webUi.Grid.AddDataResourceAttributesToSpecificElement($(this), customHeaderText[columnName].key, customHeaderText[columnName].headerText);
                            var resourceState = getCookie("resourceState");
                            if (resourceState == "ON") {
                                $(this).html(customHeaderText[columnName].key);
                            } else {
                                $(this).html(customHeaderText[columnName].headerText);
                            }
                        }

                        if (customHeaderText[columnName].template != undefined) {
                            ui.element.igGrid("setColumnTemplate", columnName, customHeaderText[columnName].template, true);
                        }
                    }
                })
            }

        },

        clickedIndicatorTile: function (evt) {
            var url = evt.url;
            if (url && _webUi.detailPane.detailPaneModel && _webUi.detailPane.detailPaneModel !== _webUi.detailPane.detailPaneEmptyModel) {
                var urlPath = url.substring(0, url.indexOf('?'));
                var urlPathValues = urlPath.split('/');
                // remove any stored advanced criteria since it isn't currently supported and could be saved from something previously
                sessionStorage.removeItem(urlPathValues[urlPathValues.length - 1] + "advanceCriteriaJson");
                url = _webUi.handlebars.getCompiledText(url, _webUi.detailPane.detailPaneModel);
                window.location = url;
            }
        }

    }
}();;
/// <reference path="../jquery-2.0.3.intellisense.js" />

// Task		| By	| Date		    | Modification Description
// ---------|-------|---------------|-------------------------
// 134373 	| MMM   | 02/19/14      | Added exportButtonClicked event
// 136001   | TDA   | 02/24/14      | Return false due to switch to MenuButton
// 136303   | AA    | 02/26/14      | Renamed viewer to insight.
// 138099   | MDL   | 03/10/14      | Added menuActionCreateCycleCount
// 138116   | RJR   | 03/11/14      | Encode Url.
// 137850   | MDL   | 03/16/14      | Added Post logic.
// 138100   | AA    | 04/02/14	    | Modified menuActionPerformPost to get the correct parameter value.
// 138905   | AA    | 04/14/14	    | Modified menuActionPerformPost to get the value from the detail pane as well.
// 140848   | RJR   | 04/22/14	    | Added menuActionPerformDelete.
// 140260   | AA    | 04/24/14	    | Added menuActionPerformGet.
// 134375   | SP    | 04/25/14      | Modified to support default success/error notifications on POST calls
// 140261   | AA    | 05/02/14      | Modifed to getQueryString and getRequestObject to get the value from heirarchical grid.
// 140880   | MDL   | 05/03/14      | Fixed export to excel.
// 140391   | RJR   | 05/09/14      | Added support for pulling data from input controls and functions.
// 145348   | MMM   | 09/11/14      | Added menuActionOpenUrl
// 146697   | MHM   | 09/11/14      | Modified the code to trim the leading spaces while saving Search Criteria on Insight Screens..
// 146664   | NRJ   | 09/30/14      | Modified the method getRequestObject such that trim happens only for string types.
// 145971   | RJR   | 10/09/14      | Moved prepForValidate & validateForm to manh.ui.validate.js
// 146384   | MJ    | 12/04/14      | Modified menuActionPerformDelete(): Building dynamic URL if needed.
// 146386   | NRJ   | 12/15/14      | Modified getRequestObject for getting the input value from igCombo
// 151453   | NRJ   | 29/12/14      | Added methods performPostWithConfirmationCallback,modalDialogPerformPostWithConfirmation.
// 150797   | MJ    | 04/07/15      | Modified performGetWithConfirmationCallback() and performPostWithConfirmationCallback(): Passing "MessageCode" to showYesNoConfirmation().
// 161013   | MHM   | 05/04/15      | Encoding the querystring values.
// 146368   | MMM   | 06/24/15      | Added postMethodErrorCallbackHandler to process confirmation messages returned from post web api method
// 162558   | MJ    | 07/02/15      | Added menuActionOpenUrlInCurrentTab.
// 162885   | MJ    | 07/13/15      | Modified getRequestObject() to fetch value from VerticaligGrid.
// 162885   | MJ    | 07/22/15      | Modified menuActionPerformPost(): processing URL from handlebar.
// 162246   | TDA   | 09/17/15      | Infragistics 2015.1 upgrade - igCombo changes
// 168801   | RS    | 11/04/15      | Modified menuActionOpenUrlInNewTab in order to include data from both queryString and detailPaneModel.
// 173870   | MDL   | 02/23/16      | Load detail pane before calling action.
// 180074   | RJR   | 06/20/16      | Support URLs embedded in a modal dialog.
// 179449   | MJ    | 06/27/16      | Modified getQueryString() to support  VerticaligGrid.
// 179449   | MJ    | 06/30/16      | Enabled encoding for preparing queryStringData in menuActionOpenUrlInNewTab.
// 179450   | MJ    | 07/07/16      | Modified menuActionOpenUrlInNewTab(): cloning detailPaneModel to prevent multiple time encoding.
// 183137   | RS    | 08/05/16      | Added query parameters to URL in menuActionPerformPost.
// 185232   | SP    | 08/29/16      | Added toggleSummaryButtonClicked to allow for hiding the summary tiles on insight screens
// 186249   | SAM   | 09/07/16      | Modified getQueryString to return empty for undefined or null
// 186835   | RJR   | 09/13/16      | Modified menuActionOpenUrlInCurrentTab to pull the same info as menuActionOpenUrlInNewTab. 
// 185489   | SP    | 09/29/16      | Added Post methods to support multiple selections
// 188069   | SAM   | 10/05/16      | Added menuActionOpenUrlInCurrentTabWithPost
// 188301   | NRJ   | 10/05/16      | Modified getRequestObjectForSelection for selecting the corrrect index.
// 188847   | SP    | 10/14/16      | Fixed getQueryString to extract data from selectedRows collection and enhanced menuActionPerformDelete to support YesNo confirmation
// 188949   | RJR   | 10/14/16      | Use proper method of fetching form id.
// 187550   | SP    | 10/17/16      | Enhanced menuActionPerformPost methods to support YesNo confirmation
// 184019   | RJR   | 10/25/16      | Support dynamic title.
// 189196   | NRJ   | 11/18/16      | Modified menuActionOpenUrlInCurrentTabWithPost(some portion of code made it generic.)
// 167148   | TDA   | 11/29/16      | ig upgrade 2016.2
// 192792  	| RJR	| 12/05/16  	| Allow for filling query params if there is no detail pane.
// 190555   | RJR   | 12/05/16      | Added toggleGroupByButtonClicked to allow for hiding the "grouping" area of main insight grid.
// 192025   | SO    | 12/06/16      | Modified getRequestObjectForSelection to pass filter criteria as request object. added canActionbeEnabled to enable the action only when filters are applied.
// 191797   | MJ    | 12/20/16      | Modified getRequestObject to handle multiselect.
// 194234   | RJR   | 12/28/16      | Sort the selectedRows after retrieving and support multi-select with confirmation. 
// 195509   | RJR   | 01/09/17      | Support single-select and no rowSelectors (checkboxes).
// 195538   | RJR   | 01/09/17      | Trim the dialog input for GET operations also.
// 195541   | RJR   | 01/09/17      | Allow system to save favorites when no rows are in the grid.
// 196645   | RJR   | 01/18/17      | Fix grouping issues. 
// 200669	| RJR	| 03/10/17      | Make safari open excel doc in new tab.
// 199305	| RS	| 03/08/16      | Added refreshGridAndCallDefaultErrorCallback.
// 205054	| RJR	| 04/27/17	    | Allow for action enabling with detail pane model values.
// 205463   | MDL	| 05/24/17	    | Added support for print preview.
// 206030	| SP 	| 06/02/17	    | Support arguments to PostData_Function type of event parameters
// 207678   | MMM   | 07/06/17      | Fixed issue for numeric values in getQueryString()
// 202292   | SO    | 09/15/16      | Added groupByCollapseClicked function.
// 219118   | NRJ   | 03/09/18      | Modified canActionbeEnabled to stop throwing undefined exception
// 225122   | PMB   | 06/21/18      | Added getInputValueForSelectedRow for correct population of selected value.  
// 225122   | PMB   | 08/08/18      | ReWork : modified getInputValueForSelectedRow for the scenario when rowId is integer.

_webUi.insightListPaneActions = function () {

    // private variables
    var _mainGridAttribute = "[data-widget=Grid]";
    var _postMethodData;
    var _postMethodSuccessCallback;
    // private functions 

    // Function implements error callback for a response received from Web API. It handles confirmation messages i.e. it prompts user with confirmation dialog box 
    // and resubmits the request if user confirms the dialog window  
    var postMethodErrorCallbackHandler = function (jqXHR, textStatus, errorThrown) {

        // Check if error is of type confirmation message
        if (jqXHR.responseJSON && jqXHR.responseJSON.ErrorType === 27) {
            var postUrl = this.url;
            _webUi.dialog.showYesNoConfirmation(jqXHR.responseJSON.Message, jqXHR.responseJSON.MessageCode).then(function (confirmed) {

                if (confirmed) {
                    // Resubmit the request without asking for confirmations
                    var index = postUrl.indexOf('?')
                    if (index > 0) {
                        if(index == (postUrl.length-1))
                            postUrl += 'processConfirmation=false';
                        else
                            postUrl += '&processConfirmation=false';
                    }
                    else
                        postUrl += '?processConfirmation=false';

                    _httpRequest.performPost(postUrl, _postMethodData, _postMethodSuccessCallback, null, false);
                }
            });

        }
        else
            _httpRequest.defaultErrorCallback(jqXHR, textStatus, errorThrown);
    };

    //Use data from both detailPaneModel and query string in order to get compiled text.
    //cloing object so encoding won't impact detailPaneModel data. 
    var createCombinedModel = function (evt) {
        var combinedModel = JSON.parse(JSON.stringify(_webUi.detailPane.detailPaneModel));
        if (combinedModel === null)
            combinedModel = new Object();
        var queryStringData = getQueryString(evt, true);
        for (var k in queryStringData)
            combinedModel[k] = queryStringData[k];
        return combinedModel;
    }

    // gets query string
    var getQueryString = function (evt, isEncodeRequired) {

        if (_webUi.detailPane.detailPaneModel === null)
            _webUi.Grid.loadDetailPaneOnToggle();

        if (_webUi.detailPane.detailPaneModel !== undefined && _webUi.detailPane.detailPaneModel !== null) {
            var querystringData = new Object();
            $.each(evt.data, function (index, value) {
                var inputValue = value;
                if (index.indexOf("queryParameter_Grid_") !== -1) {
                    querystringData[index.split("_")[3]] = getQueryStringValueFromGrid(index, value, isEncodeRequired);
                }
                else if (index.indexOf("queryParameter_Input_") !== -1) {
                    var inputId = index.split("_")[2];
                    var inputObject = $("#" + inputId);

                    if (inputObject) {
                        inputValue = _webUi.editors.getInputValue(inputObject, inputValue);
                        if (isNaN(inputValue))
                            inputValue = inputValue.trim();
                    }
                    else {
                        inputValue = undefined;
                    }

                    if ($.isEmptyObject(inputValue))
                        inputValue = "";

                    if (isEncodeRequired)
                        querystringData[index.split("_")[3]] = encodeURIComponent(inputValue);
                    else
                        querystringData[index.split("_")[3]] = inputValue;
                }
                else if (index.indexOf("queryParameter_Function_") !== -1) {
                    var nameSpaceAndFunction = _webUi.getNamespaceAndFunctionName(inputValue);
                    var arguments = _webUi.getArguments(inputValue);
                    var functionReturnValue = _webUi.executeFunctionByName(nameSpaceAndFunction, window, arguments);
                    querystringData[index.split("_")[2]] = encodeURIComponent(functionReturnValue);
                }
                else if (index.indexOf("queryParameter_") !== -1) {
                    querystringData[index.split("_")[1]] = getPlainQueryStringValue(index, value, isEncodeRequired);
                }
            });

            return querystringData;
        }
        else {
            // if there is no detail pane, we still need to check for query params in the main grid as those may still be accessed
            var querystringData = new Object();
            $.each(evt.data, function (index, value) {
                var inputValue = value;
                if (index.indexOf("queryParameter_Grid_") !== -1) {
                    querystringData[index.split("_")[3]] = getQueryStringValueFromGrid(index, value, isEncodeRequired);
                }
                else if (index.indexOf("queryParameter_Input_") !== -1) {
                    var inputId = index.split("_")[2];
                    var inputObject = $("#" + inputId);

                    if (inputObject) {
                        inputValue = _webUi.editors.getInputValue(inputObject, inputValue);
                        if (isNaN(inputValue))
                            inputValue = inputValue.trim();
                    }
                    else {
                        inputValue = undefined;
                    }

                    if ($.isEmptyObject(inputValue))
                        inputValue = "";

                    if (isEncodeRequired)
                        querystringData[index.split("_")[3]] = encodeURIComponent(inputValue);
                    else
                        querystringData[index.split("_")[3]] = inputValue;
                }
                else if (index.indexOf("queryParameter_Function_") !== -1) {
                    var nameSpaceAndFunction = _webUi.getNamespaceAndFunctionName(inputValue);
                    var arguments = _webUi.getArguments(inputValue);
                    var functionReturnValue = _webUi.executeFunctionByName(nameSpaceAndFunction, window, arguments);
                    querystringData[index.split("_")[2]] = encodeURIComponent(functionReturnValue);
                }
                else if (index.indexOf("queryParameter_") !== -1) {
                    querystringData[index.split("_")[1]] = getPlainQueryStringValue(index, value, isEncodeRequired);
                }
            });

            return querystringData;
        }

        return null;
    };

    // handles pulling plain query string values such as hard-coded values
    var getPlainQueryStringValue = function (index, value, isEncodeRequired) {
        var inputValue = value;
        if (_webUi.detailPane.detailPaneModel !== null && _webUi.detailPane.detailPaneModel[value] !== undefined)
            inputValue = _webUi.detailPane.detailPaneModel[value];

        if ($.isEmptyObject(inputValue))
            inputValue = "";

        if (isEncodeRequired)
            return encodeURIComponent(inputValue);
        else
            return inputValue;
    };

    // handles query string being pulled from grids
    var getQueryStringValueFromGrid = function (index, value, isEncodeRequired) {
        var miniGridModel = index.split("_")[2];
        var gridObject = $("#" + miniGridModel + "");
        var inputValue;

        if (gridObject.attr("data-ControlType") === "VerticaligGrid") {
            inputValue = gridObject.data('igGrid').dataSource.dataView()[0][value];
        }
        else if (gridObject.data("igGrid") != null &&
            (gridObject.igGridSelection("option", "multipleSelection") === true && gridObject.igGridSelection("selectedRows") !== null)
            || (gridObject.igGridSelection("option", "multipleSelection") === false && gridObject.igGridSelection("selectedRow") !== null && gridObject.igGridSelection('selectedRow').index > -1)) {
            var rowIndex = -1;
            var selectedId;
            if (gridObject.igGridSelection("option", "multipleSelection")) {
                var selectedRows = getSelectedRowsForMultiSelect(gridObject);                
                if (selectedRows) {
                    selectedId = selectedRows[0].id;
                    rowIndex = gridObject.igGrid('allRows').not('tr[data-grouprow=true]').index(selectedRows[0].element);
                }
            }
            else {
                selectedId = gridObject.igGrid("selectedRow").id;
                rowIndex = gridObject.igGrid('allRows').not('tr[data-grouprow=true]').index(gridObject.igGrid("selectedRow").element); 
            }

            if (rowIndex >= 0)
                inputValue = getInputValueForSelectedRow(gridObject.data('igGrid').dataSource, selectedId, value);
            else
                inputValue = undefined;
        }
        else if (gridObject.data("igGrid") != null && gridObject.attr("data-ControlType") === "igHierarchicalGrid") {
            inputValue = getSelectionOfChildrenRecursively(gridObject, value);
        }
        else {
            inputValue = undefined;
        }

        if ($.isEmptyObject(inputValue))
            inputValue = "";

        if (isEncodeRequired)
            return encodeURIComponent(inputValue);
        else
            return inputValue;
    };


    // gets request object
    var getRequestObject = function (evt) {

        if (_webUi.detailPane.detailPaneModel === null)
            _webUi.Grid.loadDetailPaneOnToggle();

        if (_webUi.detailPane.detailPaneModel !== undefined && _webUi.detailPane.detailPaneModel !== null) {
            var requestObject = {};
            $.each(evt.data, function (index, value) {
                var inputValue = value;
                if (index.indexOf("PostData_Grid_") !== -1) {
                    var miniGridModel = index.split("_")[2];
                    var gridObject = $("#" + miniGridModel + "");

                    if (gridObject.attr("data-ControlType") === "VerticaligGrid") {
                        inputValue = gridObject.data('igGrid').dataSource.dataView()[0][value];
                    }
                    else if ((gridObject.igGridSelection("option", "multipleSelection") === true && gridObject.igGridSelection('selectedRows') !== null)
                        || (gridObject.igGridSelection("option", "multipleSelection") === false && gridObject.igGridSelection("selectedRow") !== null && gridObject.igGridSelection('selectedRow').index > -1)) {
                        var rowIndex = -1;
                        var selectedId;
                        if (gridObject.igGridSelection("option", "multipleSelection")) {
                            var selectedRows = getSelectedRowsForMultiSelect(gridObject);
                            if (selectedRows) {
                                selectedId = selectedRows[0].id;
                                rowIndex = gridObject.igGrid('allRows').not('tr[data-grouprow=true]').index(selectedRows[0].element);
                            }
                        }
                        else {
                            selectedId = gridObject.igGrid("selectedRow").id;
                            rowIndex = gridObject.igGrid('allRows').not('tr[data-grouprow=true]').index(gridObject.igGrid("selectedRow").element);
                        }

                        if (rowIndex >= 0)
                            inputValue = getInputValueForSelectedRow(gridObject.data('igGrid').dataSource, selectedId, value);
                        else
                            inputValue = undefined;
                    }
                    else if (gridObject.attr("data-ControlType") === "igHierarchicalGrid") {
                        inputValue = getSelectionOfChildrenRecursively(gridObject, value);
                    }                    
                    else {
                        inputValue = 'undefined';
                    }
                    
                    requestObject[index.split("_")[3]] = inputValue;
                }
                else if (index.indexOf("PostData_Input_") !== -1) {
                    var inputId = index.split("_")[2];
                    var inputObject = $("#" + inputId);

                    if (inputObject) {
                        inputValue = _webUi.editors.getInputValue(inputObject,inputValue);

                        if (isNaN(inputValue))
                            inputValue = inputValue.trim();
                    }
                    else
                        inputValue = 'undefined';

                    requestObject[index.split("_")[3]] = inputValue;
                }
                else if (index.indexOf("PostData_Function_") !== -1) {
                    var nameSpaceAndFunction = _webUi.getNamespaceAndFunctionName(inputValue);
                    var arguments = _webUi.getArguments(inputValue);
                    var functionReturnValue = _webUi.executeFunctionByName(nameSpaceAndFunction, window, arguments);
                    requestObject[index.split("_")[2]] = functionReturnValue;
                }
                else if (index.indexOf("PostData_") !== -1) {
                    if (_webUi.detailPane.detailPaneModel[value] !== undefined)
                        inputValue = _webUi.detailPane.detailPaneModel[value];

                    requestObject[index.split("_")[1]] = inputValue;
                }               
            });

            return requestObject;
        }
        else {
            var requestObject = {};
            $.each(evt.data, function (index, value) {
                var inputValue = value;
                if (index.indexOf("PostData_Input_") !== -1) {
                    var inputId = index.split("_")[2];
                    var inputObject = $("#" + inputId);

                    if (inputObject) {
                        inputValue = _webUi.editors.getInputValue(inputObject, inputValue);

                        if (isNaN(inputValue))
                            inputValue = inputValue.trim();
                    }
                    else
                        inputValue = 'undefined';

                    requestObject[index.split("_")[3]] = inputValue;
                }
                else if (index.indexOf("PostData_Function_") !== -1) {
                    var nameSpaceAndFunction = _webUi.getNamespaceAndFunctionName(inputValue);
                    var arguments = _webUi.getArguments(inputValue);
                    var functionReturnValue = _webUi.executeFunctionByName(nameSpaceAndFunction, window, arguments);
                    requestObject[index.split("_")[2]] = functionReturnValue;
                }
            });

            return requestObject;
        }
    };
    
    //find the target grid from the event parameters if any, otherwise assume main grid
    var getGridForSelection = function (evt) {
        
        var gridObject;
        if (evt) 
        $.each(evt.data, function (index, value) {
            if (index.indexOf("PostData_Grid_") !== -1) {
                var gridId = index.split("_")[2];
                gridObject = $("#" + gridId + "");
                return false;
            }
        });
        if (!gridObject)
            gridObject = $("[data-widget=Grid]");
        
        return gridObject;
    };

    // gets request object for multi selection
    var getRequestObjectForSelection = function (evt, includeConfirmFlag) {

        var requestListFromSelection = [];
        
        var gridObject = getGridForSelection(evt);
        if (evt.data.CheckForFilters === 'true') {
            var _filtersToExecute = _webUi.insightSearchPaneActions.getAllFilterCriterias();
            _filtersToExecute.Tbl = gridObject.attr('data-dbtable');
            _filtersToExecute.GridId = gridObject.attr('data-controlId');
            var requestObject = {};
            requestObject["filters"] = _filtersToExecute;
            return requestObject;
        }
        else {
            var selectedRows = getSelectedRowsForMultiSelect(gridObject);
            if (selectedRows) {
                $.each(selectedRows, function (selectIndex, rowData) {
                    var requestObject = {};
                    $.each(evt.data, function (index, value) {
                        var inputValue = value;
                        if (index.indexOf("PostData_Grid_") !== -1) {

                            //Exclude group row for selecting right index.
                            var rowIndex = gridObject.igGrid('allRows').not('tr[data-grouprow=true]').index(selectedRows[selectIndex].element);
                            if (rowIndex >= 0) {                                
                                inputValue = getInputValueForSelectedRow(gridObject.data('igGrid').dataSource, selectedRows[selectIndex].id, value);                                
                            }
                            else
                                inputValue = undefined;

                            requestObject[index.split("_")[3]] = inputValue;
                        }
                        else if (index.indexOf("PostData_Input_") !== -1) {
                            var inputId = index.split("_")[2];
                            var inputObject = $("#" + inputId);

                            if (inputObject) {
                                inputValue = _webUi.editors.getInputValue(inputObject, inputValue);

                                if (isNaN(inputValue))
                                    inputValue = inputValue.trim();
                            }
                            else {
                                inputValue = undefined;
                            }

                            requestObject[index.split("_")[3]] = inputValue;
                        }
                        else if (index.indexOf("PostData_Function_") !== -1) {
                            var nameSpaceAndFunction = _webUi.getNamespaceAndFunctionName(inputValue);
                            var argumentNames = _webUi.getArguments(inputValue);
                            var argValues = [];
                            var argIndex;
                            for (argIndex = 0; argIndex < argumentNames.length; argIndex++)
                            {
                                switch (argumentNames[argIndex]) {
                                    //eval doesnt work for local scoped variables when minification renames the variables
                                    case 'gridObject': argValues[argIndex] = gridObject; break;
                                    case 'selectIndex': argValues[argIndex] = selectIndex; break;
                                    case 'requestObject': argValues[argIndex] = requestObject; break;
                                    default: argValues[argIndex] = eval(argumentNames[argIndex]); break;
                                }
                            }
                            var functionReturnValue = _webUi.executeFunctionByName(nameSpaceAndFunction, window, argValues);
                            requestObject[index.split("_")[2]] = functionReturnValue;
                        }

                    });

                    if (includeConfirmFlag)
                        requestObject["Confirm"] = true;
                    requestListFromSelection[selectIndex] = requestObject;
                });
            }
            return requestListFromSelection;
        }
    };

    // gets selected rows for multi-select, considering grouping, etc. Also sorts them properly
    var getSelectedRowsForMultiSelect = function (gridObject) {
        var selectedRows = gridObject.igGrid("selectedRows").filter(function (value) { return value.index >= 0 && !value.element.hasClass("ui-iggrid-groupedrow"); });
        if (selectedRows) 
            selectedRows.sort(function (a, b) { return a.index - b.index });
        return selectedRows;
    };

    // gets the seleted input value with the help of primary key, if primary key is set to grid then findRecordByKey will get the record otherwise autogenrated key will be used.
    var getInputValueForSelectedRow = function (gridDataSource, key, columnName) {
        var inputValue;
        var gridDataView = gridDataSource.dataView();
        if (gridDataView[0].ig_pk) {
            inputValue = gridDataView.filter(function (element) {
                return element.ig_pk == key;
            })[0][columnName];
        }
        else if (gridDataSource.findRecordByKey(key))
            inputValue = gridDataSource.findRecordByKey(key)[columnName];
        else
            inputValue = gridDataSource.findRecordByKey(Number(key))[columnName];
        return inputValue;
    }

    //gets all the child element as flat list and finds the slected row.
    var getSelectionOfChildrenRecursively = function (gridObject, value) {
        // get all expanded child grids
        var childGrids = gridObject.igHierarchicalGrid("allChildren");
        if (childGrids.length > 0) {
            // get the selected rows
            var selectedIndex;
            $(childGrids).each(function (index, grid) {
                var row = $(grid).igGridSelection("selectedRow");
                if (row != null) {
                    selectedIndex = row.index;
                }
            });
            if (selectedIndex > -1) {
                return childGrids.data('igGrid').dataSource.dataView()[selectedIndex][value];
            }
        }
        return null;
    };

    var performGetWithConfirmationCallback = function (response, textStatus, jqXHR, evt) {
        if (evt && evt.data.ModalDialogName)
            _webUi.dialog.hideModalDialog(evt.data.ModalDialogName);

        if (response && response.ConfirmationMessage) {
            _webUi.dialog.showYesNoConfirmation(response.ConfirmationMessage, response.MessageCode).then(function (confirmed) {
                if (confirmed) {
                    // clicked yes, call post
                    _webUi.insightListPaneActions.menuActionPerformPost(evt);
                }
                else {
                    // clicked no . . . re-show original dialog prompt to re-enter data
                    if (evt && evt.data.ModalDialogName)
                        _webUi.dialog.showModalDialog(evt.data.ModalDialogName);
                }
            });
        }
        else {
            // no confirmation required, call post
            _webUi.insightListPaneActions.menuActionPerformPost(evt);
        }
    };    

    var performPostWithConfirmationCallback = function (response, textStatus, jqXHR, evt, multiSelect) {                
        if (response && response.ConfirmationMessage) {
            _webUi.dialog.showYesNoConfirmation(response.ConfirmationMessage,response.MessageCode).then(function (confirmed) {
                if (confirmed) {
                    // clicked yes, call post
                    var requestObject = null;
                    if (multiSelect) 
                        requestObject = getRequestObjectForSelection(evt, false);
                    else
                        requestObject = getRequestObject(evt);
                    var querystringData = getQueryString(evt, true);
                    var url = evt.data.POSTServiceURL;

                    if (querystringData !== null) 
                        url = _webUi.handlebars.getCompiledText(url, querystringData);                      
                                
                    if (requestObject !== null && url !== undefined) {                        
                        var successCallbackFunction = eval(evt.data.Post_SuccessCallback);                        
                        _httpRequest.performPost(url, requestObject, successCallbackFunction, null, true);
                    }
                }
                else {
                    // clicked no . . . re-show original dialog prompt to re-enter data
                    if (evt && evt.data.ModalDialogName)
                        _webUi.dialog.showModalDialog(evt.data.ModalDialogName);
                }
            });
        }
        else 
            _webUi.insightListPaneActions.refreshGridAndCallDefaultSuccessCallback(response, textStatus, jqXHR);        
    };
        
    // generic post action with support for pre-confirmation
    var menuActionPerformPostWithPreConfirm = function (evt, request) {
        var requestObject = request;
        if (requestObject !== null && evt.data.POSTServiceURL !== undefined) {
            var successCallbackFunction = _postMethodSuccessCallback = eval(evt.data.Post_SuccessCallback); 
            var errorCallbackFunction = eval(evt.data.Post_ErrorCallback);
            var combinedModel = createCombinedModel(evt);
            var queryString = $.param(getQueryString(evt));
            var evtData = evt.data;
            ResourceJSPromise.then(function () {
                var promise;
                if (evtData.ConfirmationMessageCode) {
                    var hasTitle = (evtData.ConfirmationTitleCode !== undefined && evtData.ConfirmationTitleCode !== null && evtData.ConfirmationTitleCode !== "");
                    promise = _webUi.dialog.showYesNoConfirmation(ResourceManager.GetResource(evtData.ConfirmationMessageCode, ResourceManager.ResourceType.Msg).TEXT,
                        evtData.ConfirmationMessageCode, (hasTitle ? evtData.ConfirmationTitleCode : null),
                        (hasTitle ? ResourceManager.GetResource(evtData.ConfirmationTitleCode, ResourceManager.ResourceType.Text).TEXT : null));
                }
                else {
                    var deferred = Q.defer();
                    promise = deferred.promise;
                    deferred.resolve(true);
                }

                promise.then(function (confirmed) {
                    if (confirmed) {
                        var url = _webUi.handlebars.getCompiledText(evtData.POSTServiceURL, combinedModel);                        
                        if ($.trim(queryString))
                            url = (url.endsWith("?") ? url : url + "?") + queryString;
                        _postMethodData = requestObject;

                        _httpRequest.performPost(url, requestObject, successCallbackFunction, (errorCallbackFunction) ? errorCallbackFunction : postMethodErrorCallbackHandler, true);
                    }
                });
            })            
        }
    };


    // public functions
    return {

        // Open url(in a new tab) action
        menuActionOpenUrlInNewTab: function (evt) {

            if (_webUi.detailPane.detailPaneModel === null)
                _webUi.Grid.loadDetailPaneOnToggle();

            if (evt.data.URL !== undefined && _webUi.detailPane.detailPaneModel !== undefined) {
                var url = evt.data.URL;               
                var combinedModel = createCombinedModel(evt);
                url = _webUi.handlebars.getCompiledText(url, combinedModel);
                window.open(url);
            }
        },

        // Oper url(in a current tab) action
        menuActionOpenUrlInCurrentTab: function (evt) {

            if (_webUi.detailPane.detailPaneModel === null)
                _webUi.Grid.loadDetailPaneOnToggle();

            if (evt.data.URL !== undefined && _webUi.detailPane.detailPaneModel !== undefined) {
                var url = evt.data.URL;
                var combinedModel = createCombinedModel(evt);
                url = _webUi.handlebars.getCompiledText(url, combinedModel);
                window.location = url;
            }
        },

        // Oper url(in a current tab) with Post action
        menuActionOpenUrlInCurrentTabWithPost: function (evt) {
            
            var requestObject = getRequestObjectForSelection(evt, false);
            if (requestObject !== null && evt.data.POSTServiceURL !== undefined) {
                if (_webUi.detailPane.detailPaneModel === null)
                    _webUi.Grid.loadDetailPaneOnToggle();

                if (_webUi.detailPane.detailPaneModel !== undefined) {
                    var url = evt.data.POSTServiceURL;
                    var combinedModel = createCombinedModel(evt);
                    url = _webUi.handlebars.getCompiledText(url, combinedModel);
                    
                    _httpRequest.openUrlInCurrentTabWithPost(requestObject, url);
                }
            }
        },

        // shows URL in modal dialog
        menuActionOpenUrlInModalDialog: function (evt) {
            if (_webUi.detailPane.detailPaneModel === null)
                _webUi.Grid.loadDetailPaneOnToggle();

            if (evt !== undefined && evt.data.URL !== undefined && _webUi.detailPane.detailPaneModel !== undefined) {
                var url = evt.data.URL;
                var combinedModel = createCombinedModel(evt);
                url = _webUi.handlebars.getCompiledText(url, combinedModel);
                _webUi.dialog.showUrlInModalDialog(url);
            }
        }, 

        // generic delete action
        menuActionPerformDelete: function (evt) {
            var querystringData = getQueryString(evt);
            if (querystringData !== null && evt.data.DELETEServiceURL !== undefined) {
                var successCallbackFunction = eval(evt.data.Delete_SuccessCallback); // remove eval if we find a better way
                var evtData = evt.data;
                ResourceJSPromise.then(function () {
                    var promise;
                    if (evtData.ConfirmationMessageCode) {
                        var hasTitle = (evtData.ConfirmationTitleCode !== undefined && evtData.ConfirmationTitleCode !== null && evtData.ConfirmationTitleCode !== "");
                        promise = _webUi.dialog.showYesNoConfirmation(ResourceManager.GetResource(evtData.ConfirmationMessageCode, ResourceManager.ResourceType.Msg).TEXT,
                            evtData.ConfirmationMessageCode, (hasTitle ? evtData.ConfirmationTitleCode : null),
                            (hasTitle ? ResourceManager.GetResource(evtData.ConfirmationTitleCode, ResourceManager.ResourceType.Text).TEXT : null));
                    }
                    else {
                        var deferred = Q.defer();
                        promise = deferred.promise;
                        deferred.resolve(true);
                    }

                    promise.then(function (confirmed) {
                        if (confirmed) {
                            if (evtData.DELETEServiceURL.indexOf("{{") != -1 && evtData.DELETEServiceURL.indexOf("}}") != -1) {
                                var serviceURL = _webUi.handlebars.getCompiledText(evtData.DELETEServiceURL, querystringData);
                                _httpRequest.performDelete(serviceURL, successCallbackFunction, null, true);                    
                            }
                            else {
                                _httpRequest.performDelete(evtData.DELETEServiceURL + $.param(querystringData), successCallbackFunction, null, true);
                            }
                        }
                    });
                })                
            }
        },

        // generic get action
        menuActionPerformGet: function (evt) {
            var querystringData = getQueryString(evt);
            if (querystringData !== null && evt.data.GETServiceURL !== undefined)
                _httpRequest.performGet(evt.data.GETServiceURL + $.param(querystringData), null, null, false, true);
        },     

        // generic post action
        menuActionPerformPost: function (evt) {
            var requestObject = getRequestObject(evt);
            menuActionPerformPostWithPreConfirm(evt, requestObject);
        },

        // generic post action for multi selection
        menuActionPerformPostForSelection: function (evt) {
            var requestObject = getRequestObjectForSelection(evt, false);
            menuActionPerformPostWithPreConfirm(evt, requestObject);
        },

        // generic delete action from modal dialog
        modalDialogPerformDelete: function (evt) {
            if (_webUi.validate.validateModalDialogForm(evt)) {
                _webUi.insightListPaneActions.menuActionPerformDelete(evt);

                if (evt && evt.data.ModalDialogName)
                    _webUi.dialog.hideModalDialog(evt.data.ModalDialogName);
            }

            return false;
        },       

        // generic get action
        modalDialogPerformGet: function (evt) {
            if (_webUi.validate.validateModalDialogForm(evt)) {
                _webUi.insightListPaneActions.menuActionPerformGet(evt);

                if (evt && evt.data.ModalDialogName)
                    _webUi.dialog.hideModalDialog(evt.data.ModalDialogName);
            }

            return false;
        },

        // generic get action
        modalDialogPerformGetWithConfirmation: function (evt) {
            if (_webUi.validate.validateModalDialogForm(evt)) {
                var querystringData = getQueryString(evt);
                if (querystringData !== null && evt.data.GETServiceURL !== undefined)
                    _httpRequest.performGet(evt.data.GETServiceURL + $.param(querystringData), function (data, textStatus, jqXHR) { performGetWithConfirmationCallback(data, textStatus, jqXHR, evt) }, null, false, true);
            }

            return false;
        },

        // generic post action with confirmation after modal dialog prompt
        modalDialogPerformPostWithConfirmation: function (evt) {
            if (_webUi.validate.validateModalDialogForm(evt)) {
                var requestObject = getRequestObject(evt);
                var querystringData = getQueryString(evt, true);
                var url = evt.data.POSTServiceURL;

                if (querystringData !== null)
                    url = _webUi.handlebars.getCompiledText(url, querystringData);

                if (requestObject !== null && evt.data.POSTServiceURL !== undefined) {                    
                    requestObject["Confirm"] = true;
                    _httpRequest.performPost(url, requestObject, function (data, textStatus, jqXHR) { performPostWithConfirmationCallback(data, textStatus, jqXHR, evt, false) }, null, true);
                }

                if (evt && evt.data.ModalDialogName)
                    _webUi.dialog.hideModalDialog(evt.data.ModalDialogName);
            }
            return false;
        },

        // generic post action with confirmation after modal dialog prompt
        modalDialogPerformPostWithConfirmationForSelection: function (evt) {
            if (_webUi.validate.validateModalDialogForm(evt)) {
                var requestObject = getRequestObjectForSelection(evt, true);
                var querystringData = getQueryString(evt, true); 
                var url = evt.data.POSTServiceURL;

                if (querystringData !== null)
                    url = _webUi.handlebars.getCompiledText(url, querystringData);

                if (requestObject !== null && evt.data.POSTServiceURL !== undefined) 
                    _httpRequest.performPost(url, requestObject, function (data, textStatus, jqXHR) { performPostWithConfirmationCallback(data, textStatus, jqXHR, evt, true) }, null, true);

                if (evt && evt.data.ModalDialogName)
                    _webUi.dialog.hideModalDialog(evt.data.ModalDialogName);
            }
            return false;
        },

        // generic post action
        modalDialogPerformPost: function (evt) {
            if (_webUi.validate.validateModalDialogForm(evt)) {
                _webUi.insightListPaneActions.menuActionPerformPost(evt);

                if (evt && evt.data.ModalDialogName)
                    _webUi.dialog.hideModalDialog(evt.data.ModalDialogName);
            }

            return false;
        },

        // generic post action for multiple selection
        modalDialogPerformPostForSelection: function (evt) {
            if (_webUi.validate.validateModalDialogForm(evt)) {
                _webUi.insightListPaneActions.menuActionPerformPostForSelection(evt);

                if (evt && evt.data.ModalDialogName)
                    _webUi.dialog.hideModalDialog(evt.data.ModalDialogName);
            }
            return false;
        },
                               
        // export to excel button click event
        exportButtonClicked: function () {
            var $formObject = $("#exportToExcelForm");
            var exportToExcelActionUrl = $formObject.attr("action").replace(/ListPaneGridDataSourceBind/, "ExportToExcel");
            var requestBody = JSON.parse($formObject.attr("data-requestBody"));
            $.each(requestBody, function (index, value) {
                $formObject.find("input[name=" + index + "]").remove();
                $('<input>').attr({
                    type: 'hidden',
                    name: index,
                    value: value
                }).appendTo($formObject);
            });

            //Post temporary form on ExportToExcel action to download the excel file
            $formObject
                 .attr("action", exportToExcelActionUrl)
                 .attr("method", "post")
                 .attr("data-ajax-method", "POST")
                 .attr("data-ajax", "true")
                 .attr("target", _webUi.isSafari() ? "_blank" : "")
                 .submit();
            return false;

        },

        // refreshes the grid first and then calls default callback for any messages that need to be displayed
        refreshGridAndCallDefaultSuccessCallback: function (data, textStatus, jqXHR) {
            if (data && $.trim(data.Message)) 
                _webUi.Grid.refreshData();

            _httpRequest.defaultSuccessCallback(data, textStatus, jqXHR);
        },

        // refreshes the grid first and then calls default error callback
        refreshGridAndCallDefaultErrorCallback: function (jqXHR, textStatus, errorThrown) {
            
            _webUi.Grid.refreshData();
            _httpRequest.defaultErrorCallback(jqXHR, textStatus, errorThrown);
        },

        //show/hide the "grouping" area of main insight grid
        toggleGroupByButtonClicked: function (evt) {
            var insightGrid = $(_mainGridAttribute).first();
            if (insightGrid) {
                var groupingVal = insightGrid.igGridGroupBy("option", "groupByAreaVisibility");

                // if it is currently top, change it to "hidden"; otherwise, change it to "top"
                var isVisible = false;
                if (groupingVal && groupingVal === "top") {
                    insightGrid.igGridGroupBy("option", "groupByAreaVisibility", "hidden");
                    $('.groupByToggle').removeClass('visiblepane');
                    isVisible = false;
                }
                else {
                    insightGrid.igGridGroupBy("option", "groupByAreaVisibility", "top");
                    $('.groupByToggle').addClass('visiblepane');
                    isVisible = true;
                }

                //save display preference
                var screenId = WebUi.prototype.getCurrentFormId();
                localStorage[screenId + "InsightGridGrouping-displayPreferenceVisible" + _webSession.UserName()] = isVisible;
            }
        }, 

        groupByCollapseClicked: function (data) {
            var insightGrid = $(_mainGridAttribute).first();
            if (insightGrid && insightGrid.igGridGroupBy("option", "groupedColumns").length > 0) {
                var ds = insightGrid.data("igGrid").dataSource;
                var dataView = ds.groupByDataView();
                for (var i = 0; i < dataView.length; i++) {
                    var rec = dataView[i];
                    if (rec.__gbRecord) {
                        ds.toggleGroupByRecord(rec.id, true);
                    }
                }
                ds.dataBind();
            }
            
        },

        //show/hide the List pane summary panel on insight screens
        toggleSummaryButtonClicked: function (evt) {
            var summaryPanel = $('.listpanesummarypanel');
            if (summaryPanel) {
                summaryPanel.toggle(); //show or hide

                //change height to fill space
                var listPaneContainer = $('div[data-name="ListPanePanel"]').parent();
                if (summaryPanel.is(':visible')) {
                    $(this).addClass('visiblepane');
                    listPaneContainer.switchClass('listpanepanelnosummarytiles', 'listpanepanel');
                    summaryPanel.resize();
                }
                else {
                    $(this).removeClass('visiblepane');
                    listPaneContainer.switchClass('listpanepanel', 'listpanepanelnosummarytiles');
                }
                //save display preference
                var screenId = WebUi.prototype.getCurrentFormId();
                localStorage[screenId + "ListPaneSummary-displayPreferenceVisible" + _webSession.UserName()] = summaryPanel.is(':visible');
            }
        },

        //This function evaluates whether to enable or disable insight actions based on controlId or view model field passed
        canActionbeEnabled: function (evtParam, value) {
            var enable = true;
            var conditionLeft;
            
            if (evtParam.split("_")[3] !== undefined && evtParam.split("_")[3] === "DetailPane") {

                if (_webUi.detailPane.detailPaneModel)
                    conditionLeft = eval("_webUi.detailPane.detailPaneModel." + evtParam.split("_")[2]);
            }
            else
                conditionLeft = $("#" + evtParam.split("_")[2]).text();

            if (conditionLeft !== undefined && conditionLeft !== "") {
                var evalCondition = value.replace(new RegExp(evtParam.split("_")[2], 'g'), conditionLeft)
                if (!eval(evalCondition)) {
                    enable = false;
                }
            }
            else {
                enable = false;
            }
            return enable;
        },

        getQueryString: function (evt) {
            return getQueryString(evt);
        },

        createCombinedModel: function (evt) {
            return createCombinedModel(evt);
        }
    }
}();;
/// <reference path="../jquery-2.0.3.intellisense.js" />

// Task		| By	| Date		    | Modification Description
// ---------|-------|---------------|-------------------------
// 133104  	| RJR	| 12/18/13  	| Created
// 134705   | RJR   | 12/27/13      | Refactored w/ better jQuery performance practices.
// 135696   | RJR   | 01/08/14      | Modified to use Sql view.
// 134705   | RJR   | 01/14/14      | Fill list pane on search button click.
// 134368   | MDL   | 01/16/14      | Added evt args logic.
// 136463   | RJR   | 02/13/14      | Determine if company or warehouse is actually a filter added to the screen.
// 134713   | RJR   | 02/19/14      | Process toggle switches and html attributes logic.
// 134373 	| MMM   | 02/19/14      | Added getAllFilterCriterias method 
// 133017	| MDL	| 02/03/14	    | added its own databind method
// 136001   | TDA   | 02/24/14      | Return false due to switch to MenuButton
// 136303   | AA    | 02/26/14      | Renamed viewer to insight.
// 138104 	| RJR   | 02/25/14      | Set the control id on the filters. 
// 138099   | MDL   | 03/10/14      | Modified href from link to javascript.
// 138166   | RJR   | 03/10/14      | Pass extra value for summary tiles and shorten field names.
// 138302   | RJR   | 03/13/14      | Support wildcard searches.
// 139475   | RJR   | 03/19/14      | Use data-name selector instead of css class selector.
// 140385   | RJR   | 04/11/14      | Support DateRange and DateTimeRange controls.
// 140376   | RJR   | 04/15/14      | Support saving of searches.
// 140382   | RJR   | 04/19/14      | When a user adds a new saved search, add it to the drop down list.
// 140379   | RJR   | 04/21/14      | Add support for applying of saved search.
// 141106   | RJR   | 04/28/14      | Support hiearchical checked list box.
// 141156   | MDL   | 04/29/14      | Modify as we are getting title data with grid data.
// 141156   | MDL   | 04/29/14      | set url on datasource in such a way that sorting state is not disappear.
// 140391   | RJR   | 05/05/14      | Added validation for inputs and modal dialog.
// 141714   | RJR   | 05/06/14      | Pass data type for checked list boxes.
// 140391   | RJR   | 05/11/14      | Make getSearchPartId global method.
// 138907   | MMM   | 05/20/14      | getFilterCriteriaFromQueryString() and applyInputFilterCriteria()
// 143243   | SAM   | 06/03/14      | Added setMainInsightGridDataSource
// 141225   | AA    | 08/12/14      | Added Delete http request for deleting saved search also added applyRemoveSavedSearchCallback.
// 145721   | AA    | 08/14/14      | Modified applyRemoveSavedSearchCallback to remove the delete saved search item from drop down.
// 145741   | AA    | 08/14/14      | Modified applyRemoveSavedSearchCallback to use innerHTML instead of innerText as it is not supported in other browser.
// 147507   | AA    | 09/22/14      | Modified Advanced search criteria grid name from SearchPaneAdvCrit_AdvCritGrid to SearchPaneAdvCritAdvCritGrid.
// 150797   | MJ    | 04/07/15      | Modified applySavedSearchClicked(): Passing "MessageCode" to showYesNoConfirmation().
// 159561   | MHM   | 04/07/15      | Added condition controlType === "igDateTimeEditor" in getInputFiltersForExecutingSearch() function.
// 163398   | AH    | 07/15/15      | Modified getInputFiltersForExecutingSearch() to add condition controlType === "igDatePicker" and added timezone offset. 
// 163995   | DN    | 07/28/15      | Added unCheckAll and checkSelectedFilters
// 133807   | MDL   | 08/31/15      | Added getComboMultiSelectWithCheckBoxFiltersForExecutingSearch
// 165585   | NRJ   | 09/23/15      | Modified "Multi select combo with checkboxes" such that it supports for parent/child relation in a single row.
// 162246   | TDA   | 09/17/15      | Infragistics 2015.1 upgrade 
// 166883   | DN    | 09/29/15      | set default values for multiselectcheckbox
// 168632   | MDL   | 10/27/15      | Check for active index before setting fltr values for combo.
// 167675   | SP    | 10/29/15      | Fixed getComboMultiSelectWithCheckBoxFiltersForExecutingSearch to properly support parent-child values from cascading combos
// 167755   | TDA   | 11/11/15      | Changes to support BootstrapToggle
// 170980   | KSS   | 01/09/16      | Added code to apply advance search criteria.
// 173708   | RJR   | 02/05/16      | igDatePicker was not being processed correctly in saved searches.
// 168622   | TDA   | 02/12/16      | Fixed deleting saved searches
// 172360   | KSS   | 02/18/16      | Modified applyAdvanceFilterCriteria()
// 173301   | RJR   | 02/24/16      | Updated as the favorites menu has been movedout of search pane part. 
// 172359   | KSS   | 03/01/16      | Changes made to get the toggle switch value from query string value.
// 173329   | RJR   | 03/07/16      | Add a filter badge and clear option. 
// 169894   | MDL   | 03/15/16      | Modified for review label on focus and empty on blur.
// 184494   | NRJ   | 08/23/16      | Fixed an issue with the company filter.
// 185870   | RJR   | 09/06/16      | Allow filters to be passed by database column name as well.
// 187940   | TDA   | 10/17/16      | Fixed or conditions
// 188947   | RJR   | 10/20/16      | Handle initial action enabling for grids that start with grouped columns. 
// 167148   | TDA   | 11/29/16      | ig upgrade 2016.2
// 193328   | TDA   | 12/09/16      | Fixed combo filters 
// 194099   | RJR   | 12/14/16      | Support filter statements from insight screens.
// 196608   | RJR   | 01/17/17      | Fix nav issue when user clears out warehouse.
// 196814   | DN    | 01/20/17      | Modified to check for all warehouse column names in clearAndEnableOrDisableComboCheckedListBoxFilters
// 195603   | RJR   | 01/23/17      | Support today vs. custom date controls.
// 196534   | SO    | 02/01/17      | Modified getFilterCriteriaFromQueryString to prevent double decoding as decoding is already taken care in GetQueryStringParams.
// 199073   | RJR   | 03/07/17      | Change how current warehouse is retrieved.
// 199224   | KSS   | 03/10/17      | Modified to pass false value for shouldDefaultWhs
// 197253   | DP    | 03/21/17      | Modified isWarehouseFilters to avoid clearing default warehouse
// 203511   | SO    | 04/12/17      | Modified applySavedInputFilters to call UpdateInlineLabelOnFocus for controls of type igComboMultiSelectWithCheckBox.
// 203511   | SO    | 04/18/17      | Modified getFiltersQueryString and applySavedInputFilters to update inline label for the controls in search pane.
// 203942   | RJR   | 05/05/17      | Allow advanced criteria to be passed in query string also.
// 205680   | MMM   | 06/07/17      | Modified getFilterCriteriaFromQueryString to process filter list passed in string representation of json object
// 205995   | TDA   | 06/13/17      | Handle fields using COALESCE
// 207698   | TDA   | 06/14/17      | Replaced : with â (ALT+219) delimiter
// 208593   | DP    | 07/14/17      | Modified LaborActivityType config to allow custom value
// 204237   | MMM   | 07/18/17      | MOdified getAdvancedFilterCriteriaFromQueryString to combine advanced criteria from both query string and session storage
// 211610   | SO    | 07/08/17      | Modified getFiltersQueryString to consider child values in query string for igComboMultiSelectWithCheckBox control.
// 208906   | MK    | 09/07/17      | Modified searchButtonClicked() and getFiltersForExecutingSearch() to set rtnRslts flag.
// 212226   | MK    | 09/08/17      | Modified clearButtonClicked() to clear filte and badge instad of refersh data. 
// 201423   | MMM   | 08/17/17      | Modified advanced criteria populating logic to consider condition(and/or) as passed in param value and populate the resource text of fields
//                                    (which isn't passed from calling screen) after loading the Reosurce JS
// 209760   | SHS   | 09/12/17      | Added events for handling stop search 
// 213848   | MMM   | 10/24/17      | Modified advanced criteria population logic to consider all types of operands
// 213555   | SHS   | 11/08/17      | Modified to use window.onload instead of ready, to have the code called after all javascript is available.
// 215810   | MK    | 11/10/17      | Modified fillListPaneSummaryTiles() to set summary pane data to zero if list pane grid don't have nay data, modified getTileCount() to store data.
// 217036   | SO    | 01/04/17      | Modified to handle datetime values for navigation trail and save search
// 218998   | KSS   | 02/16/18      | Modified code to set focus on search on search click event   
// 227487   | PMB   | 09/25/18      | Modified setFiltersStorageForAdvancedFilters for the population of ConditionIdentifier.
// 230295   | SHS   | 02/05/19      | Fixed javascript errors.
// 233801   | MHM   | 04/15/19      | Fixed the advance criteria.  
// 247903   | PMB   | 03/09/20      | Modfied getAdvancedGridRecords to  decodeURIComponent while populating fldName.
// 249814   | MGK   | 04/13/20      | Removed checking displayvalue with Valueidentifier because it only works when regional format is of english-US
// 252300   | PMB   | 06/15/20      | Modified fillListPaneGridBasedOnSearchFilters to use igGridSelection's clearSlection instead of _webUi.Grid.deSelectAllSelectedRows as its
//                                  | Clears all selected cells, selected rows, active cell and active row.Also updates the UI accordingly.
_webUi.insightSearchPaneActions = function () {
    // private variables
    var _searchPaneCriteriaGroup = "[data-name=SearchPaneCriteria]";
    var _searchPanePart = "[data-name=SearchPane]";
    var _insightMenuPanePart = "[data-name=InsightMenuPane]";
    var _mainGridAttribute = "[data-widget=Grid]";
    var _advCriteriaGridName = "SearchPaneAdvCritAdvCritGrid";
    var _hasCompFltr = false;
    var _hasWhsFltr = false;
    var _mainInsightGrid;
    var _gridUrlWithToken;
    var _filtersToExecute;
    var _summaryPanePreviousResponse = {};
   
    $(window).load(function () { $('#InsightMenuActionStopSearch').closest('li').removeClass("dropdownaction disabled"); });
    // private functions

    // applies saved advanced criteria filters
    var applySavedAdvancedCriteriaFilters = function (savedAdvancedCriteriaFilters) {
        var controlSelector;

        // process filters - they should always be in saved search so no need to try to remove current records - datasource will be overwritten
        if (savedAdvancedCriteriaFilters) {
            for (var x = 0; x < savedAdvancedCriteriaFilters.length; x++) {
                controlSelector = $("#" + savedAdvancedCriteriaFilters[x].name);
                controlSelector.igGrid("option", "dataSource", savedAdvancedCriteriaFilters[x].value);
            }
        }
    };

    // applies saved checked list box filters
    var applySavedCheckedListBoxFilters = function (savedCheckedListBoxFilters) {
        var controlSelector;
        var nodeArray;
        var uncheckedNodes;
        var currentNodeIdentifier;

        // uncheck nodes for all checked list boxes
        clearAndEnableOrDisableCheckedListBoxFilters(true, true);

        // process filters
        if (savedCheckedListBoxFilters) {
            for (var x = 0; x < savedCheckedListBoxFilters.length; x++) {
                controlSelector = $("[id=" + savedCheckedListBoxFilters[x].name + "]");
                nodeArray = savedCheckedListBoxFilters[x].value;
                if (nodeArray) {
                    // check nodes that should be checked
                    for (var y = 0; y < nodeArray.length; y++) {
                        uncheckedNodes = controlSelector.igTree("uncheckedNodes");
                        if (uncheckedNodes) {
                            for (var z = 0; z < uncheckedNodes.length; z++) {
                                // identifier has to match and can't directly search on it
                                currentNodeIdentifier = uncheckedNodes[z].data.Identifier;
                                if (currentNodeIdentifier === nodeArray[y]) {
                                    controlSelector.igTree("toggleCheckstate", uncheckedNodes[z].element);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    var getIgComboCustomData = function (value) {
        return [{
            data: {
                Default: false,
                Description: value,
                Identifier: value,
                IdentifierAndDescription: ""
            }
        }];
    };


    // applies saved combo checked list box filters
    var applySavedComboCheckedListBoxFilters = function (savedCheckedListBoxFilters) {
        var controlSelector;
        var nodeArray;

        // uncheck nodes for all checked list boxes
        clearAndEnableOrDisableComboCheckedListBoxFilters(true, true, false);

        // process filters
        if (savedCheckedListBoxFilters) {
            for (var x = 0; x < savedCheckedListBoxFilters.length; x++) {
                controlSelector = $("[id=" + savedCheckedListBoxFilters[x].name + "]");
                _webUi.label.UpdateInlineLabelOnFocus("", controlSelector);
                nodeArray = savedCheckedListBoxFilters[x].value;
                if (nodeArray) {
                    controlSelector.igCombo("value", nodeArray);
                }
                else {
                    nodeArray = savedCheckedListBoxFilters[x].text;
                    controlSelector.igCombo("text", nodeArray);
                }
            }
        }
    };

    // applies saved hierarchical checked list box filters
    var applySavedHierarchicalCheckedListBoxFilters = function (savedHierCheckedListBoxFilters) {
        var controlSelector;
        var nodeArray;
        var childrenNodes;
        var parentValue;
        var currentParentNode;

        // uncheck parent nodes for all hierarchical checked list boxes (which will uncheck everything)
        clearAndEnableOrDisableHierarchicalCheckedListBoxFilters(true, true);

        // process filters
        if (savedHierCheckedListBoxFilters) {
            for (var x = 0; x < savedHierCheckedListBoxFilters.length; x++) {
                controlSelector = $("[id=" + savedHierCheckedListBoxFilters[x].name + "]");

                var parentNodes = savedHierCheckedListBoxFilters[x].value;
                if (parentNodes) {
                    for (var y = 0; y < parentNodes.length; y++) {
                        // we only need to check the child nodes, igTree will take care of the rest
                        parentValue = parentNodes[y].val;
                        currentParentNode = controlSelector.igTree("findNodesByText", parentValue)[0].element;
                        nodeArray = parentNodes[y].childrenVals;
                        if (nodeArray && nodeArray.length > 0) {
                            // check nodes that should be checked
                            childrenNodes = controlSelector.igTree("children", currentParentNode);
                            if (childrenNodes) {
                                for (var z = 0; z < nodeArray.length; z++) {
                                    for (var i = 0; i < childrenNodes.length; i++) {
                                        // identifier has to match and can't directly search on it
                                        currentNodeIdentifier = childrenNodes[i].data.Identifier;
                                        if (currentNodeIdentifier === nodeArray[z]) {
                                            controlSelector.igTree("toggleCheckstate", childrenNodes[z].element);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            // if there are no child nodes then check the parent directly
                            controlSelector.igTree("toggleCheckstate", currentParentNode);
                        }
                    }
                }
            }
        }
    };

    // applies saved input filters
    var applySavedInputFilters = function (savedInputFilters) {
        var controlSelector;
        var controlType;

        // clear all current values in input fields
        clearAndEnableOrDisableInputFilters(true, true, true);

        // process filters
        if (savedInputFilters) {
            for (var x = 0; x < savedInputFilters.length; x++) {
                controlSelector = $("#" + savedInputFilters[x].name);
                controlType = controlSelector.attr('data-controlType');
                if (!controlType) {
                    controlSelector = $("[data-dbColumn=" + savedInputFilters[x].name + "]");
                    controlType = controlSelector.attr('data-controlType');
                    if (!controlType) {
                        controlSelector = $("[data-parentdbcolumn=" + savedInputFilters[x].name + "]");
                        controlType = controlSelector.attr('data-controlType');
                    }
                }

                if (controlType) {
                    if (controlType === "igTextEditor") {
                        controlSelector.igTextEditor("value", savedInputFilters[x].value);
                        if (savedInputFilters[x].value)
                            _webUi.label.UpdateInlineLabelOnFocus("", controlSelector);
                    }
                    if (controlType === "igNumericEditor") {
                        controlSelector.igNumericEditor("value", savedInputFilters[x].value);
                        if (savedInputFilters[x].value)
                            _webUi.label.UpdateInlineLabelOnFocus("", controlSelector);
                    }
                    else if (controlType === "igDateTimeEditor") {
                        controlSelector.igDateEditor("value", new Date(savedInputFilters[x].value));
                        if (savedInputFilters[x].value)
                            _webUi.label.UpdateInlineLabelOnFocus("", controlSelector);
                    }
                    else if (controlType === "igDatePicker") {
                        controlSelector.igDatePicker("value", new Date(savedInputFilters[x].value));
                        if (savedInputFilters[x].value)
                            _webUi.label.UpdateInlineLabelOnFocus("", controlSelector);
                    }
                    else if (controlType === "igCombo") {
                        controlSelector.igCombo("value", savedInputFilters[x].value);
                        if (savedInputFilters[x].value.length > 0)
                            _webUi.label.UpdateInlineLabelOnFocus("", controlSelector);
                    }
                    else if (controlType === "CheckedListBox") {
                        if (savedInputFilters[x].value !== null) {
                            if (savedInputFilters[x].value !== "") {
                                var checkListValues = savedInputFilters[x].value.split('$');
                                if (checkListValues.length > 0) {
                                    unCheckAll(controlSelector);
                                    checkSelectedFilters(controlSelector, checkListValues);
                                }
                            }
                        }
                    }
                    else if (controlType === "igComboMultiSelectWithCheckBox") {
                        if (savedInputFilters[x].value !== null) {
                            if (savedInputFilters[x].value !== "") {
                                controlSelector.igCombo("deselectAll");
                                var checkListValues = savedInputFilters[x].value.split('$');
                                controlSelector.igCombo("value", checkListValues);
                                _webUi.label.UpdateInlineLabelOnFocus("", controlSelector);
                            }
                            else {
                                controlSelector.igCombo("deselectAll");
                                _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);
                                controlSelector.removeAttr("data-defaultTopLabel");
                            }
                        }
                    }
                    else if (controlType === "ToggleSwitch") {
                        controlSelector = $("[id=" + savedInputFilters[x].name + "]");

                        if (savedInputFilters[x].value.toUpperCase() === "TRUE")
                            controlSelector.bootstrapToggle('on');
                        else
                            controlSelector.bootstrapToggle('off');
                    }
                }
            }
        }
    };

    var unCheckAll = function (controlSelector) {
        checkedNodes = controlSelector.igTree("checkedNodes");
        if (checkedNodes) {
            for (var x = 0; x < checkedNodes.length; x++) {
                var parentNode = controlSelector.igTree("parentNode", checkedNodes[x].element);
                if (!parentNode)
                    controlSelector.igTree("toggleCheckstate", checkedNodes[x].element);
            }
        }
    };

    var checkSelectedFilters = function (controlSelector, checkListValues) {
        uncheckedNodes = controlSelector.igTree("uncheckedNodes");
        if (uncheckedNodes) {
            for (var x = 0; x < uncheckedNodes.length; x++) {
                for (var y = 0; y < checkListValues.length; y++) {
                    currentNodeIdentifier = uncheckedNodes[x].data.Identifier;
                    if (currentNodeIdentifier === checkListValues[y]) {
                        controlSelector.igTree("toggleCheckstate", uncheckedNodes[x].element);
                        break;
                    }
                }
            }
        }
    };

    // apply saved search success callback
    var applySavedSearchCallback = function (data) {
        var savedFilters = JSON.parse(data.SearchValue);

        applySavedInputFilters(savedFilters.inSearch);
        applySavedCheckedListBoxFilters(savedFilters.chkbxSearch);
        applySavedComboCheckedListBoxFilters(savedFilters.comboChkbxSearch)
        applySavedHierarchicalCheckedListBoxFilters(savedFilters.hierChkbxSearch);
        applySavedToggleFilters(savedFilters.togSearch);
        applySavedAdvancedCriteriaFilters(savedFilters.advSearch);

        _webUi.insightSearchPaneActions.searchButtonClicked();
    };

    // apply remove saved search success callback
    var applyRemoveSavedSearchCallback = function (data) {
        var deleteSearchName = data.SearchName.trim();
        var match = $('*[data-controltype=SavedSearchesMenu] span:contains(' + deleteSearchName + ')').closest('li');
        $.each(match, function (key, value) {
            if ($(this).find('span')[0].innerHTML == deleteSearchName) {
                $(this).remove();
                return false;
            }
        });
        deleteSavedSearch(deleteSearchName); // this call is part of inline javascript generated in SavedSearchesMenu.cs
    };

    // applies saved toggle filters
    var applySavedToggleFilters = function (savedToggleFilters) {
        var controlSelector;

        // process filters - no need to clear any current values because these are always passed as either on/off in the json
        if (savedToggleFilters) {
            for (var x = 0; x < savedToggleFilters.length; x++) {
                controlSelector = $("[id=" + savedToggleFilters[x].name + "]");

                if (savedToggleFilters[x].value)
                    controlSelector.bootstrapToggle('on');
                else
                    controlSelector.bootstrapToggle('off');
            }
        }
    };

    // clear any input filters
    var enableOrDisableLookupButtons = function (enable) {
        $("div.lookupbutton").find("button").each(function () {
            $(this).prop("disabled", !enable);
        });
    };

    // clear advanced criteria
    var clearAndEnableOrDisableAdvancedCriteria = function (clear, enable) {
        var gridSelector = $("#SearchPaneAdvCritAdvCritGrid");

        if (gridSelector) {
            if (clear === true) {
                var dataSource = gridSelector.igGrid("option", "dataSource");
                if (dataSource && dataSource.Records && dataSource.Records.length > 0) {
                    // need to pull out primary keys for rows first because if you loop through length right away and delete rows, the length changes and not everything gets deleted
                    var primaryKeys = [];
                    for (var x = 0; x < dataSource.Records.length; x++) {
                        primaryKeys[x] = dataSource.Records[x].PrimaryKey;
                    }

                    for (var y = 0; y < primaryKeys.length; y++) {
                        gridSelector.igGridUpdating("deleteRow", primaryKeys[y]);
                    }
                }
            }
            
            if (enable === true) 
                $("#SearchPaneAdvCrit_AddButton").prop("disabled", false).removeClass("disabled");
            else 
                $("#SearchPaneAdvCrit_AddButton").prop("disabled", true).addClass("disabled");
                
        }
    };

    // clear checked list box filters
    var clearAndEnableOrDisableCheckedListBoxFilters = function (clear, enable) {
        var fieldId;
        var controlSelector;
        var checkedNodes;
        var checkedListBoxSelector = $(_searchPaneCriteriaGroup);
        checkedListBoxSelector.find("[data-controlType='CheckedListBox']").each(function () {
            fieldId = $(this).attr('id');
            controlSelector = $("#" + fieldId);

            if (clear === true) {
                checkedNodes = controlSelector.igTree("checkedNodes");
                if (checkedNodes) {
                    for (var x = 0; x < checkedNodes.length; x++)
                        controlSelector.igTree("toggleCheckstate", checkedNodes[x].element);
                }
            }

            // not sure we can completely disable igTree, if we could, we would do it here. currently we have no insight screens with igTree controls.
        });
    };

    // clear combo checked list boxes
    var clearAndEnableOrDisableComboCheckedListBoxFilters = function (clear, enable, shouldDefaultWhs) {
        var fieldId;
        var controlSelector;
        var comboCheckedListBoxSelector = $(_searchPaneCriteriaGroup);
        comboCheckedListBoxSelector.find("[data-controlType='igComboMultiSelectWithCheckBox']").each(function () {
            fieldId = $(this).attr('id');
            controlSelector = $("#" + fieldId);

            controlSelector.igCombo("option", "disabled", !enable);
            if (enable === false)
                _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);

            if (clear === true) {
                if (controlSelector.attr("data-dbcolumn") !== undefined && isWarehouseFilter(controlSelector.attr("data-dbcolumn").toUpperCase()) && shouldDefaultWhs === true) {
                    controlSelector.igCombo("value", _webSession.CurrentWhs());
                    _webUi.label.UpdateInlineLabelOnFocus("", controlSelector);
                }
                else {
                    controlSelector.igCombo("value", "");
                    _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);
                }
            }
        });
    };

    // clear hierarchical checked list box filters
    var clearAndEnableOrDisableHierarchicalCheckedListBoxFilters = function (clear, enable) {
        var fieldId;
        var controlSelector;
        var checkedNodes;
        var checkedListBoxSelector = $(_searchPaneCriteriaGroup);
        checkedListBoxSelector.find("[data-controlType='HierarchicalCheckedListBox']").each(function () {
            fieldId = $(this).attr('id');
            controlSelector = $("#" + fieldId);

            if (clear === true) {
                checkedNodes = controlSelector.igTree("checkedNodes");
                if (checkedNodes) {
                    for (var x = 0; x < checkedNodes.length; x++) {
                        var parentNode = $("#" + fieldId).igTree("parentNode", checkedNodes[x].element);
                        if (!parentNode)
                            controlSelector.igTree("toggleCheckstate", checkedNodes[x].element);
                    }
                }
            }

            // not sure we can completely disable igTree, if we could, we would do it here. currently we have no insight screens with igTree controls.
        });
    };   

    // clear any input filters
    var clearAndEnableOrDisableInputFilters = function (clear, enable, clearInsightFilterStmtCtrl) {
        var fieldName;
        var manualEnablingAndDisabling = false;
        var controlSelector;
        var controlType;
        var searchPaneSelector = $(_searchPaneCriteriaGroup);
        searchPaneSelector.find("input").each(function () {
            fieldName = $(this).attr('name');
            manualEnablingAndDisabling = $("#" + fieldName).attr('data-manualEnablingAndDisabling');
            manualEnablingAndDisabling = manualEnablingAndDisabling && manualEnablingAndDisabling === "true" ? true : false;

            if (fieldName) {
                controlSelector = $("#" + fieldName);
                controlType = controlSelector.attr('data-controlType');

                if (controlType && shouldBeIncludedInFilters(fieldName)) {
                    if (controlType === "igTextEditor") {
                        if (clear === true) {
                            controlSelector.igTextEditor("clearButton").click();
                            _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);
                        }
                        if (manualEnablingAndDisabling !== true)
                            controlSelector.igTextEditor("option", "disabled", !enable);
                    }
                    if (controlType === "igNumericEditor") {
                        if (clear === true) {
                            controlSelector.igNumericEditor("clearButton").click();
                            _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);
                        }
                        if (manualEnablingAndDisabling !== true)
                            controlSelector.igNumericEditor("option", "disabled", !enable);
                    }
                    else if (controlType === "igDatePicker") {
                        if (clear === true) {
                            controlSelector.igDatePicker("clearButton").click();
                            _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);
                        }
                        if (manualEnablingAndDisabling !== true)
                            controlSelector.igDatePicker("option", "disabled", !enable);
                    }
                    else if (controlType === "igDateTimeEditor") {
                        if (clear === true) {
                            controlSelector.igDateEditor("clearButton").click();
                            _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);
                        }
                        if (manualEnablingAndDisabling !== true)
                            controlSelector.igDateEditor("option", "disabled", !enable);
                    }
                    else if (controlType === "igCombo") {
                        var isFilterStmtControl = isFilterStatementControl(controlSelector);
                        if (isFilterStmtControl === false) {
                            if (clear === true) {
                                controlSelector.igCombo("value", null);
                                _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);
                            }
                            if (manualEnablingAndDisabling !== true)
                                controlSelector.igCombo("option", "disabled", !enable);
                        }
                        else if (isFilterStmtControl === true && clearInsightFilterStmtCtrl) {
                            controlSelector.igCombo("value", null);
                            _webUi.label.UpdateInlineLabelOnBlur("", controlSelector);
                        }
                    }
                }
            }
        });
    };

    // clear and enable or disable all search pane controls other than the filter statement control
    var clearAndEnableOrDisableSearchPaneControlsOtherThanFilterStatement = function (clear, enable, clearInsightFilterStmtCtrl) {
        clearAndEnableOrDisableAdvancedCriteria(clear, enable);
        clearAndEnableOrDisableCheckedListBoxFilters(clear, enable);
        clearAndEnableOrDisableComboCheckedListBoxFilters(clear, enable, enable);
        clearAndEnableOrDisableHierarchicalCheckedListBoxFilters(clear, enable);
        clearAndEnableOrDisableInputFilters(clear, enable, clearInsightFilterStmtCtrl);
        resetToggleSwitchesToInitialStateAndEnableOrDisable(clear, enable);
        enableOrDisableLookupButtons(enable);
    };

    // reset all toggle switches to initial state
    var resetToggleSwitchesToInitialStateAndEnableOrDisable = function (clear, enable) {
        var searchPaneSelector = $(_searchPaneCriteriaGroup);
        searchPaneSelector.find("[data-controlType='ToggleSwitch']").each(function () {
            fieldId = $(this).attr('id');

            if (fieldId) {
                if (clear === true) {
                    var initialState = $("#" + fieldId).attr('data-initialState');

                    if (initialState && initialState === "on")
                        $(this).bootstrapToggle('on');
                    else
                        $(this).bootstrapToggle('off');
                }

                $(this).bootstrapToggle((enable === true ? 'enable' : 'disable'));
            }
        });
    };

    // fill the list pane based on the search filters specified
    var fillListPaneGridBasedOnSearchFilters = function (filtersJson) {
        if (!_mainInsightGrid)
            _mainInsightGrid = $(_mainGridAttribute).first();

        // save off the url with token in it so that we can replace the token each time they hit search
        var currentGridUrl = _mainInsightGrid.igGrid("option", "dataSource");
        if (!_gridUrlWithToken)
            _gridUrlWithToken = currentGridUrl;
        var newGridUrl = _gridUrlWithToken.replace(/filterToken/g, encodeURIComponent(filtersJson)); // "g" is flag for global replacement

        _mainInsightGrid.data("igGrid").dataSource.settings.dataSource = newGridUrl;
        $('#InsightMenuActionStopSearch').closest('li').removeClass("dropdownaction disabled");        
        _mainInsightGrid.data("igGrid")._loadingIndicator.show();
        _mainInsightGrid.igGridPaging("pageIndex", 0);       
        $(_mainInsightGrid).igGridSelection("clearSelection");
    };

    // get all controls of type AdvancedCriteria and returns the filters for query execution
    var getAdvancedCriteriaFiltersForExecutingSearch = function () {
        var advGridName;
        var advGridData;
        var advFltrs = [];

        // process all advanced criteria grids
        $(_searchPaneCriteriaGroup).find("[id$='AdvCritGrid']").each(function () {
            advGridName = $(this).attr('id');
            advGridData = $("#" + advGridName).igGrid("option", "dataSource");

            if (advGridData && advGridData.Records && advGridData.Records.length > 0) {
                // fill an object that can be added to the advanced filter list
                var advancedCriteriaFilter = new Object();
                advancedCriteriaFilter.cond = getFilterCondition(advGridData);

                // now process grid that goes with this filter condition
                advancedCriteriaFilter.grdFltrs = getAdvancedGridRecords(advGridData);

                // add to filters list
                advFltrs.push(advancedCriteriaFilter);
            }
        });

        if (advFltrs.length > 0)
            return advFltrs;
        else
            return null;
    };

    // get all controls of type AdvancedCriteria and returns the filters for saving search
    var getAdvancedCriteriaFiltersForSavingSearch = function () {
        var advGridName;
        var advGridData;
        var advFltrs = [];

        // process all advanced criteria grids
        $(_searchPaneCriteriaGroup).find("[id$='AdvCritGrid']").each(function () {
            advGridName = $(this).attr('id');
            advGridData = $("#" + advGridName).igGrid("option", "dataSource");

            var advancedCriteriaFilter = new Object();
            advancedCriteriaFilter.name = advGridName;
            advancedCriteriaFilter.value = advGridData;
            advFltrs.push(advancedCriteriaFilter);
        });

        if (advFltrs.length > 0)
            return advFltrs;
        else
            return null;
    };

    // returns grid filters
    var getAdvancedGridRecords = function (gridRows) {
        grdFltrs = [];

        if (gridRows && gridRows.Records) {
            for (var x = 0, len = gridRows.Records.length; x < len; x++) {
                grdFltr = new Object();
                grdFltr.type = gridRows.Records[x].DataType;
                grdFltr.fld = gridRows.Records[x].FieldIdentifier;
                grdFltr.fldName = decodeURIComponent(gridRows.Records[x].Field);
                grdFltr.op = gridRows.Records[x].OperandIdentifier;
                grdFltr.opName = gridRows.Records[x].Operand;
                if (gridRows.Records[x].DataType === "DT" && gridRows.Records[x].ValueIdentifier !== "")
                    grdFltr.val = new Date(gridRows.Records[x].ValueIdentifier).toISOString().slice(0, 19).replace('T', ' ');
                else
                    grdFltr.val = gridRows.Records[x].ValueIdentifier;

                grdFltr.valDsply = gridRows.Records[x].Value;
                grdFltrs.push(grdFltr);
            }
        }

        return grdFltrs;
    };

    // get all controls of type CheckedListBox and return the filters for query execution
    var getCheckedListBoxFiltersForExecutingSearch = function () {
        var fieldName;
        var columnName;
        var fieldId;
        var dataType;
        var checkedItems;
        var uncheckedItems;
        var checkedListBoxFilters = [];

        // process all checkedListBox controls
        var checkedListBoxSelector = $(_searchPaneCriteriaGroup);
        checkedListBoxSelector.find("[data-controlType='CheckedListBox']").each(function () {
            fieldName = $(this).attr('name');
            fieldId = $(this).attr('id');
            columnName = $("#" + fieldId).attr('data-dbcolumn');
            dataType = $("#" + fieldName).attr('data-dataType');
            if (!dataType)
                dataType = $(this).attr('data-dataType');
            _hasCompFltr = _hasCompFltr || isCompanyFilter(columnName);
            _hasWhsFltr = _hasWhsFltr || isWarehouseFilter(columnName);

            // if every checkbox is checked, then send nothing because everything is allowed and BL will take care of any required validations (like whs/comp)
            // note that the div is sometimes counted as unchecked so make sure that "path" is defined in the first unchecked element
            uncheckedItems = $("#" + fieldId).igTree("uncheckedNodes");
            if (uncheckedItems && uncheckedItems.length > 0 && uncheckedItems[0].path) {
                checkedItems = $("#" + fieldId).igTree("checkedNodes");

                if (checkedItems && checkedItems.length > 0 && checkedItems[0].data) {
                    checkedListBoxFilter = new Object();
                    checkedListBoxFilter.type = dataType;
                    checkedListBoxFilter.fld = columnName;
                    checkedListBoxFilter.val = getIdentifiers(checkedItems, false);
                    checkedListBoxFilters.push(checkedListBoxFilter);
                }
                else {
                    checkedListBoxFilter = new Object();
                    checkedListBoxFilter.type = dataType;
                    checkedListBoxFilter.fld = columnName;
                    checkedListBoxFilter.val = null;
                    checkedListBoxFilters.push(checkedListBoxFilter);
                }
            }
            else {
                checkedListBoxFilter = new Object();
                checkedListBoxFilter.type = dataType;
                checkedListBoxFilter.fld = columnName;
                checkedListBoxFilter.val = ["*All"];
                checkedListBoxFilters.push(checkedListBoxFilter);
            }
        });

        if (checkedListBoxFilters.length > 0)
            return checkedListBoxFilters;
        else
            return null;
    };


    // get all controls of type combo with checkedListBox controlsand return the filters for query execution
    var getComboMultiSelectWithCheckBoxFiltersForExecutingSearch = function () {
        var fieldName;
        var columnNames = [];
        var fieldId;
        var dataType;
        var checkedItems;
        var uncheckedItems;
        var checkedListBoxFilters = [];
        var comboBox;

        // process all combo with checkedListBox controls
        var comboWithCheckedListBoxSelector = $(_searchPaneCriteriaGroup);
        comboWithCheckedListBoxSelector.find("[data-controlType='igComboMultiSelectWithCheckBox']").each(function () {
            fieldName = $(this).attr('name');
            fieldId = $(this).attr('id');

            columnNames = [];
            comboBox = $("#" + fieldId);

            if (comboBox.attr('data-parentdbcolumn') !== undefined && comboBox.attr('data-childdbcolumn') !== undefined) {
                columnNames.add(comboBox.attr('data-parentdbcolumn'));
                columnNames.add(comboBox.attr('data-childdbcolumn'));
            }
            else
                columnNames.add(comboBox.attr('data-dbcolumn'));

            dataType = $("#" + fieldName).attr('data-dataType');
            if (!dataType)
                dataType = $(this).attr('data-dataType');
            var isWhsFilter = isWarehouseFilter(columnNames[0]);
            _hasCompFltr = _hasCompFltr || isCompanyFilter(columnNames[0]);
            _hasWhsFltr = _hasWhsFltr || isWhsFilter;

            if (columnNames.count() === 1) {
                checkedListBoxFilter = new Object();
                checkedListBoxFilter.type = dataType;
                checkedListBoxFilter.fld = columnNames[0];
                // if nothing is checked, then it means we don't want filter with checkbox
                checkedItems = $("#" + fieldId).igCombo("value");
                if (checkedItems && checkedItems.length > 0)
                    checkedListBoxFilter.val = checkedItems;
                else {
                    checkedListBoxFilter.val = ["*All"];
                    if (isWhsFilter)
                        $(this).removeAttr("data-defaultTopLabel");
                }
                checkedListBoxFilters.push(checkedListBoxFilter);
            }

            if (columnNames.count() === 2) {
                var selectedItems = $("#" + fieldId).igCombo("selectedItems");

                if (selectedItems) {

                    var identifierValues = [];
                    var descriptionValues = [];
                    for (i = 0; i < selectedItems.length ; i++) {

                        identifierValues.push(selectedItems[i].data.Identifier);
                        //values without child values should be inserted as null in the list
                        descriptionValues.push(selectedItems[i].data.Description);
                    }

                    if (identifierValues && identifierValues.length > 0) {
                        checkedListBoxFilter = new Object();
                        checkedListBoxFilter.type = dataType;
                        checkedListBoxFilter.fld = columnNames[0];
                        checkedListBoxFilter.val = identifierValues;

                        checkedListBoxFilter.childfld = columnNames[1];
                        checkedListBoxFilter.childrenVals = descriptionValues;
                        checkedListBoxFilters.push(checkedListBoxFilter);
                    }
                }
                else {
                    var values = $("#" + fieldId).igCombo("value");

                    checkedListBoxFilter = new Object();
                    checkedListBoxFilter.type = dataType;
                    checkedListBoxFilter.fld = columnNames[0];
                    checkedListBoxFilter.val = values;

                    checkedListBoxFilters.push(checkedListBoxFilter);
                }
            }

        });

        if (checkedListBoxFilters.length > 0)
            return checkedListBoxFilters;
        else
            return null;
    };

    // get all controls of type CheckedListBox and return the filters for saving search
    var getCheckedListBoxFiltersForSavingSearch = function () {
        var fieldId;
        var checkedItems;
        var checkedListBoxFilters = [];

        // process all checkedListBox controls
        var checkedListBoxSelector = $(_searchPaneCriteriaGroup);
        checkedListBoxSelector.find("[data-controlType='CheckedListBox']").each(function () {
            fieldId = $(this).attr('id');
            checkedItems = $("#" + fieldId).igTree("checkedNodes");

            if (checkedItems && checkedItems.length > 0 && checkedItems[0].data) {
                checkedListBoxFilter = new Object();
                checkedListBoxFilter.name = fieldId;
                checkedListBoxFilter.value = getIdentifiers(checkedItems);
                checkedListBoxFilters.push(checkedListBoxFilter);
            }
        });

        if (checkedListBoxFilters.length > 0)
            return checkedListBoxFilters;
        else
            return null;
    };

    // get all controls of type CheckedListBox and return the filters for saving search
    var getComboCheckedListBoxFiltersForSavingSearch = function () {
        var fieldId;
        var checkedItems;
        var checkedListBoxFilters = [];

        // process all checkedListBox controls
        var checkedListBoxSelector = $(_searchPaneCriteriaGroup);
        checkedListBoxSelector.find("[data-controlType='igComboMultiSelectWithCheckBox']").each(function () {
            fieldId = $(this).attr('id');
            checkedItems = $("#" + fieldId).igCombo("value");

            var comboBox = $("#" + fieldId);

            if (checkedItems && checkedItems.length > 0) {
                checkedListBoxFilter = new Object();
                checkedListBoxFilter.name = fieldId;
                checkedListBoxFilter.value = checkedItems;
                checkedListBoxFilters.push(checkedListBoxFilter);

                if (comboBox.attr('data-parentdbcolumn') !== undefined && comboBox.attr('data-childdbcolumn') !== undefined) {
                    checkedListBoxFilter = new Object();
                    checkedListBoxFilter.name = fieldId;
                    checkedListBoxFilter.text = $("#" + fieldId).igCombo("text");
                    checkedListBoxFilters.push(checkedListBoxFilter);
                }
            }
        });

        if (checkedListBoxFilters.length > 0)
            return checkedListBoxFilters;
        else
            return null;
    };

    // retrieve column name from control name
    var getColumnNameFromDataBindAttribute = function (dataBindAttribute) {
        if (dataBindAttribute) {
            var lastIndex = dataBindAttribute.lastIndexOf(":");
            if (lastIndex > -1)
                return dataBindAttribute.substring(lastIndex + 1, dataBindAttribute.length).trim();
        }

        return "";
    };

    // retrieve control id from grid attribute
    var getControlIdFromGrid = function () {
        if (!_mainInsightGrid)
            _mainInsightGrid = $(_mainGridAttribute).first();

        return _mainInsightGrid.attr('data-controlId');
    };

    var getFilterCriteriaFromQueryString = function () {

        var searchCriteria = GetQueryStringParams("filters");
        var filterCriteriasList;
        var parameterName;
        var parameterValue;
        var inSearch = [];

        if (searchCriteria && searchCriteria.length > 0) {

            // process filter list in json object format
            if (searchCriteria.startsWith("{")) {
                filterCriteriasList = $.parseJSON(searchCriteria);
                var inSearchobj;
                for (var prop in filterCriteriasList) {
                    inSearchobj = new Object();
                    inSearchobj.name = prop;
                    inSearchobj.value = filterCriteriasList[prop];
                    inSearch.push(inSearchobj)
                }
            }
            else {
                filterCriteriasList = searchCriteria.split(',');

                if (filterCriteriasList && filterCriteriasList.length > 0) {
                    var inSearchobj;

                    for (var i = 0; i < filterCriteriasList.length; i++) {
                        inSearchobj = new Object();
                        criteria = new Object();
                        criteria = filterCriteriasList[i].split('â');

                        if (criteria && criteria.length > 0) {
                            inSearchobj.name = criteria[0];

                            for (var j = 1; j < criteria.length; j++) {

                                if (j > 1)
                                    inSearchobj.value += 'â' + criteria[j];
                                else
                                    inSearchobj.value = criteria[j];
                            }
                           
                            inSearch.push(inSearchobj);
                        }
                    }
                }
            }
        }

        return inSearch;
    };

    var getAdvancedFilterCriteriaFromQueryString = function (formId) {
        var fromDashboard = GetQueryStringParams("fromDashboard");
        if (fromDashboard)
            sessionStorage.removeItem(formId.value + "advanceCriteriaJson");//Clear session storage value

        var searchCriteria = GetQueryStringParams("advancedFilters");
        var advancedSearchFiltersList = [];

        // advanced filters in query string take priority; if those exist don't look in local storage; we will never use both query string and local storage.
        if (searchCriteria && searchCriteria.length > 0) {
            
            var filterCriteriasList = searchCriteria.split(',');
            if (filterCriteriasList && filterCriteriasList.length > 0) {
                for (var i = 0; i < filterCriteriasList.length; i++) {
                    filterCriteriasList[i] = filterCriteriasList[i];
                    filterListSplit = filterCriteriasList[i].split('â');
                    if (filterListSplit) {
                        if (filterListSplit.length === 7) {
                            advancedSearchFiltersList.push({
                                FieldIdentifier: decodeURIComponent(filterListSplit[0]).replace(/&quot;/g, "\""),
                                Field: decodeURIComponent(filterListSplit[1]).replace(/&quot;/g, "\""),
                                ValueIdentifier: decodeURIComponent(filterListSplit[4]).replace(/&quot;/g, "\""),
                                Value: decodeURIComponent(filterListSplit[5]).replace(/&quot;/g, "\""),
                                Operand: getOperand(decodeURIComponent(filterListSplit[3]).replace(/&quot;/g, "\""), decodeURIComponent(filterListSplit[2]).replace(/&quot;/g, "\"")),
                                OperandIdentifier: decodeURIComponent(filterListSplit[2]).replace(/&quot;/g, "\""),
                                DataType: decodeURIComponent(filterListSplit[6]).replace(/&quot;/g, "\"")
                            });
                        }
                        else if (filterListSplit.length === 9) {
                            advancedSearchFiltersList.push({
                                FieldIdentifier: decodeURIComponent(filterListSplit[0]).replace(/&quot;/g, "\""),
                                Field: decodeURIComponent(filterListSplit[1]).replace(/&quot;/g, "\""),
                                ValueIdentifier: decodeURIComponent(filterListSplit[4]).replace(/&quot;/g, "\""),
                                Value: decodeURIComponent(filterListSplit[5]).replace(/&quot;/g, "\""),
                                Operand: getOperand(decodeURIComponent(filterListSplit[3]).replace(/&quot;/g, "\""), decodeURIComponent(filterListSplit[2]).replace(/&quot;/g, "\"")),
                                OperandIdentifier: decodeURIComponent(filterListSplit[2]).replace(/&quot;/g, "\""),
                                DataType: decodeURIComponent(filterListSplit[6]).replace(/&quot;/g, "\""),
                                ConditionIdentifier: decodeURIComponent(filterListSplit[7]).replace(/&quot;/g, "\""),
                                Condition: decodeURIComponent(filterListSplit[8]).replace(/&quot;/g, "\"")
                            });
                        }
                    }
                }
            }
        }

        var advancedSearchFiltersFromStorage = JSON.parse(sessionStorage.getItem(formId.value + "advanceCriteriaJson"));

        if (advancedSearchFiltersFromStorage && advancedSearchFiltersFromStorage.length > 0)
        {
            $.each(advancedSearchFiltersFromStorage, function (index, value) {
                advancedSearchFiltersList.push(value);
            });
        }

        return advancedSearchFiltersList;
    };

    var getOperand = function (operand, operandIdentifier) {
        if (operand)
            return operand;

        switch (operandIdentifier) {
            case '10':
                return "=";
            case '20':
                return "!=";
            case '30':
                return "<";
            case '40':
                return "<=";
            case '50':
                return ">";
            case '60':
                return ">=";
            case "70":
                return "like";
            case "80":
                return "not like";
            case "90":
                return "is not null";
            case "100":
                return "is null";
            default:
                return "";
        }
    };

    var applyAdvanceFilterCriteria = function (advanceSearchCriterias, formId) {

        if (advanceSearchCriterias != null && JSON.stringify(advanceSearchCriterias).length > 2) {
            var gridSelector = $("#" + "SearchPaneAdvCrit" + "AdvCritGrid");           

            $.each(advanceSearchCriterias, function (index, advanceSearchCrtJson) {
                var condition;
                var conditionIdentifier;
                if ($.trim(advanceSearchCrtJson['ConditionIdentifier']) === "20") {
                    conditionIdentifier = "20";
                    condition = "Any are met (OR)";
                }
                else {
                    conditionIdentifier = "10";
                    condition = "All are met (AND)";
                }

                gridSelector.igGridUpdating('addRow', {
                    'ConditionIdentifier': conditionIdentifier,
                    'Condition': condition,
                    'FieldIdentifier': advanceSearchCrtJson['FieldIdentifier'],
                    'Field': advanceSearchCrtJson['Field'],
                    'OperandIdentifier': advanceSearchCrtJson['OperandIdentifier'] !== undefined ? advanceSearchCrtJson['OperandIdentifier'] : "10",
                    'Operand': advanceSearchCrtJson['Operand'] !== undefined ? advanceSearchCrtJson['Operand'] : "=",
                    'ValueIdentifier': advanceSearchCrtJson['DataType'] === "I" ? parseInt(advanceSearchCrtJson['ValueIdentifier']) : advanceSearchCrtJson['ValueIdentifier'],
                    'Value': advanceSearchCrtJson['DataType'] === "I" && !isNaN(parseInt(advanceSearchCrtJson['Value'])) ? parseInt(advanceSearchCrtJson['Value']) : advanceSearchCrtJson['Value'],
                    'DataType': advanceSearchCrtJson['DataType'] !== undefined ? advanceSearchCrtJson['DataType'] : "A",
                    'PrimaryKey': _webUi.createGuid()
                });
            });

            // Set resource text for field column in advanced criteria grid if it's not populated by default
            // Url redirections with advnaced filters doesn't pass the resource text in the url
            ResourceJSPromise.then(function () {
                var gridSelector = $("#" + "SearchPaneAdvCrit" + "AdvCritGrid");
                
                if (gridSelector && gridSelector.data("igGrid") !== null && gridSelector.data("igGrid") !== undefined && gridSelector.igGrid('rows').length > 0)
                {
                    // Check if advnaced criterias doesn't have field values(display text of field names)
                    if (!$.trim(gridSelector.igGrid("getCellValue", $(gridSelector.igGrid('rows')[0]).attr("data-id"), "Field")))
                    {
                        $.each(gridSelector.igGrid('rows'), function (index, row) {
                            gridSelector.igGridUpdating("setCellValue", $(row).attr('data-id'), "Field", ResourceManager.GetResource(gridSelector.igGrid("getCellValue", $(row).attr("data-id"), "FieldIdentifier").replace(/\_/g, ''), ResourceManager.ResourceType.Text).TEXT);
                        });
                    }
                }

            });
        }

        //Clear session storage value.
        sessionStorage.removeItem(formId.value + "advanceCriteriaJson");

    };


    // returns all filters for query execution
    var getFiltersForExecutingSearch = function () {
        var fieldValue;
        var fieldName;
        var basicCriteria = [];
        var hasFilterStmtApplied = false;

        insightSearchCriteria = new Object();

        //Set returnResults and rtnRslts flag to true if user has clicked search button
        if (_webUi.insightSearchPaneActions.userClickedSearchButton)
            _webUi.insightSearchPaneActions.returnResults = _webUi.insightSearchPaneActions.userClickedSearchButton;
        insightSearchCriteria.rtnRslts = _webUi.insightSearchPaneActions.returnResults;

        var filterStmtCtrl = $("[data-insightFilterRecType]").first();
        if (filterStmtCtrl) {
            var filterStatement = getFilterStatementNameForExecutingSearch(filterStmtCtrl);
            var filterRecordType = getFilterStatementRecordTypeForExecutingSearch(filterStmtCtrl);
            if (filterStatement && filterRecordType) {
                hasFilterStmtApplied = true;
                insightSearchCriteria.fltrStmt = filterStatement;
                insightSearchCriteria.fltrRecType = filterRecordType;
                clearAndEnableOrDisableSearchPaneControlsOtherThanFilterStatement(true, false, false);
            }
        }

        if (hasFilterStmtApplied !== true)
            clearAndEnableOrDisableSearchPaneControlsOtherThanFilterStatement(false, true, false);

        // process all input controls (excluding the advanced criteria inputs)
        var inFltrs = getInputFiltersForExecutingSearch();
        if (inFltrs)
            insightSearchCriteria.inFltrs = inFltrs;

        // process all checkedlistbox controls
        var checkedListBoxFilters = getCheckedListBoxFiltersForExecutingSearch();
        if (checkedListBoxFilters)
            insightSearchCriteria.chkbxFltrs = checkedListBoxFilters;

        // process all igComboMultiSelectWithCheckBox controls
        var comboMultiSelectWithCheckBox = getComboMultiSelectWithCheckBoxFiltersForExecutingSearch();
        if (comboMultiSelectWithCheckBox) {
            if (insightSearchCriteria.chkbxFltrs !== undefined && insightSearchCriteria.chkbxFltrs != null)
                insightSearchCriteria.chkbxFltrs = insightSearchCriteria.chkbxFltrs.concat(comboMultiSelectWithCheckBox);
            else
                insightSearchCriteria.chkbxFltrs = comboMultiSelectWithCheckBox;
        }

        // process all hierarchicalcheckedlistbox controls
        var hierCheckedListBoxFilters = getHierarchicalCheckedListBoxFiltersForExecutingSearch();
        if (hierCheckedListBoxFilters)
            insightSearchCriteria.hierChkbxFltrs = hierCheckedListBoxFilters;

        // process all toggle switch controls
        var togFltrs = getToggleFiltersForExecutingSearch();
        if (togFltrs)
            insightSearchCriteria.togFltrs = togFltrs;

        // process all advanced criteria controls
        var advFltrs = getAdvancedCriteriaFiltersForExecutingSearch();
        if (advFltrs)
            insightSearchCriteria.advFltrs = advFltrs;

        // set these to global values now and then reset the values
        insightSearchCriteria.HasCompFltr = _hasCompFltr;
        insightSearchCriteria.HasWhsFltr = _hasWhsFltr;
        _hasCompFltr = false;
        _hasWhsFltr = false;

        // set filter badge count and return filters
        setFilterBadgeCount(insightSearchCriteria);
        return insightSearchCriteria;
    };

    // returns all filters for saving search
    var getFiltersForSavingSearch = function () {
        filledSearchFields = new Object();

        // process all input controls 
        var inputSearch = getInputFiltersForSavingSearch();
        if (inputSearch)
            filledSearchFields.inSearch = inputSearch;

        // process all checkedlistbox controls
        var checkedListBoxSearch = getCheckedListBoxFiltersForSavingSearch();
        if (checkedListBoxSearch)
            filledSearchFields.chkbxSearch = checkedListBoxSearch;

        // process all Combo with checkedlistbox controls
        var comboCheckedListBoxSearch = getComboCheckedListBoxFiltersForSavingSearch();
        if (comboCheckedListBoxSearch)
            filledSearchFields.comboChkbxSearch = comboCheckedListBoxSearch;

        // process all hierarchical checkedlistbox controls
        var hierCheckedListBoxSearch = getHierarchicalCheckedListBoxFiltersForSavingSearch();
        if (hierCheckedListBoxSearch)
            filledSearchFields.hierChkbxSearch = hierCheckedListBoxSearch;

        // process all toggle switch controls
        var togSearch = getToggleFiltersForSavingSearch();
        if (togSearch)
            filledSearchFields.togSearch = togSearch;

        // process all advanced criteria controls
        var advSearch = getAdvancedCriteriaFiltersForSavingSearch();
        if (advSearch)
            filledSearchFields.advSearch = advSearch;

        return JSON.stringify(filledSearchFields, _webUi.dateReplacer);
    };

    // returns just the filter condition for the advanced criteria grid
    var getFilterCondition = function (gridRows) {
        if (gridRows && gridRows.Records) {

            var andCondition = true;

            $.each(gridRows.Records, function (i, theItem) {

                //If any of the rows have "OR" we need to process the filter as an OR
                if (theItem.ConditionIdentifier === "20") {
                    andCondition = false;
                }
            });

           if (andCondition)
                return "10";
            else
                return "20";
        }
        else {
        return null;
        }
    };

    // get filter statement name for query execution
    var getFilterStatementNameForExecutingSearch = function (filterStmtCtrl) {
        if (filterStmtCtrl) {
            var selectedItems = filterStmtCtrl.igCombo("selectedItems");
            if (selectedItems && selectedItems[0] && selectedItems[0].data)
                return selectedItems[0].data.Identifier;
            else
                return null;
        }
        else {
            return null;
        }
    };

    // get filter statement name for query execution
    var getFilterStatementRecordTypeForExecutingSearch = function (filterStmtCtrl) {
        if (filterStmtCtrl) 
            return filterStmtCtrl.attr("data-insightFilterRecType");
        else
            return null;
    };

    // get all controls of type HierarchicalCheckedListBox and return the filters for query execution
    var getHierarchicalCheckedListBoxFiltersForExecutingSearch = function () {
        var fieldName;
        var parentColumnName;
        var childColumnName;
        var fieldId;
        var dataType;
        var checkedItems;
        var partiallyCheckedItems;
        var uncheckedItems;
        var hierCheckedListBoxFilters = [];

        // process all hierarchical checkedListBox controls
        var hierCheckedListBoxSelector = $(_searchPaneCriteriaGroup);
        hierCheckedListBoxSelector.find("[data-controlType='HierarchicalCheckedListBox']").each(function () {
            fieldName = $(this).attr('name');
            fieldId = $(this).attr('id');
            parentColumnName = $("#" + fieldId).attr('data-parentdbcolumn');
            childColumnName = $("#" + fieldId).attr('data-childdbcolumn');
            dataType = $("#" + fieldName).attr('data-dataType');
            if (!dataType)
                dataType = $(this).attr('data-dataType');
            _hasCompFltr = _hasCompFltr || isCompanyFilter(parentColumnName);
            _hasWhsFltr = _hasWhsFltr || isWarehouseFilter(parentColumnName);
            _hasCompFltr = _hasCompFltr || isCompanyFilter(childColumnName);
            _hasWhsFltr = _hasWhsFltr || isWarehouseFilter(childColumnName);

            // if every checkbox is checked, then send nothing because everything is allowed and BL will take care of any required validations (like whs/comp)
            // note that the div is sometimes counted as unchecked so make sure that "path" is defined in the first unchecked element
            uncheckedItems = $("#" + fieldId).igTree("uncheckedNodes");
            if (uncheckedItems && uncheckedItems.length > 0 && uncheckedItems[0].path) {
                checkedItems = $("#" + fieldId).igTree("checkedNodes");
                partiallyCheckedItems = $("#" + fieldId).igTree("partiallyCheckedNodes");

                if (checkedItems && checkedItems.length > 0 && checkedItems[0].data) {
                    hierCheckedListBoxFilter = new Object();
                    hierCheckedListBoxFilter.type = dataType;
                    hierCheckedListBoxFilter.fld = parentColumnName;
                    hierCheckedListBoxFilter.childfld = childColumnName;
                    hierCheckedListBoxFilter.val = getIdentifiersForHierarchical(checkedItems, partiallyCheckedItems, fieldId);
                    hierCheckedListBoxFilters.push(hierCheckedListBoxFilter);
                }
                else {
                    hierCheckedListBoxFilter = new Object();
                    hierCheckedListBoxFilter.type = dataType;
                    hierCheckedListBoxFilter.fld = parentColumnName;
                    hierCheckedListBoxFilter.childfld = childColumnName;
                    hierCheckedListBoxFilter.val = null;
                    hierCheckedListBoxFilters.push(hierCheckedListBoxFilter);
                }
            }
            else {
                hierCheckedListBoxFilter = new Object();
                hierCheckedListBoxFilter.type = dataType;
                hierCheckedListBoxFilter.fld = parentColumnName;
                hierCheckedListBoxFilter.childfld = childColumnName;
                hierCheckedListBoxFilter.val = getIdentifiersWhenAllBoxesCheckedHierarchical();
                hierCheckedListBoxFilters.push(hierCheckedListBoxFilter);
            }
        });

        if (hierCheckedListBoxFilters.length > 0)
            return hierCheckedListBoxFilters;
        else
            return null;
    };

    // get all controls of type HierarchicalCheckedListBox and return the filters for saving search
    var getHierarchicalCheckedListBoxFiltersForSavingSearch = function () {
        var fieldId;
        var checkedItems;
        var partiallyCheckedItems;
        var hierCheckedListBoxFilters = [];

        // process all hierarchical checkedListBox controls
        var hierCheckedListBoxSelector = $(_searchPaneCriteriaGroup);
        hierCheckedListBoxSelector.find("[data-controlType='HierarchicalCheckedListBox']").each(function () {
            fieldId = $(this).attr('id');
            checkedItems = $("#" + fieldId).igTree("checkedNodes");
            partiallyCheckedItems = $("#" + fieldId).igTree("partiallyCheckedNodes");

            if (checkedItems && checkedItems.length > 0 && checkedItems[0].data) {
                hierCheckedListBoxFilter = new Object();
                hierCheckedListBoxFilter.name = fieldId;
                hierCheckedListBoxFilter.value = getIdentifiersForHierarchical(checkedItems, partiallyCheckedItems, fieldId);
                hierCheckedListBoxFilters.push(hierCheckedListBoxFilter);
            }
        });

        if (hierCheckedListBoxFilters.length > 0)
            return hierCheckedListBoxFilters;
        else
            return null;
    };

    // returns just the identifiers from the checked items array passed
    var getIdentifiers = function (checkedItemsArray) {
        identifiersArray = [];

        if (checkedItemsArray) {
            for (var x = 0, len = checkedItemsArray.length; x < len; x++) {
                identifiersArray.push(checkedItemsArray[x].data.Identifier);
            }
        }

        return identifiersArray;
    };

    // returns the parent (with embedded children) identifiers from the checked items arrays passed
    var getIdentifiersWhenAllBoxesCheckedHierarchical = function () {
        hierIdentifiersArray = [];

        parentNode = new Object();
        parentNode.val = "*All";
        parentNode.childrenVals = ["*All"];
        hierIdentifiersArray.push(parentNode);

        return hierIdentifiersArray;
    };

    // returns just the child identifiers for the parent passed
    var getIdentifiersForHierarchicalChild = function (parentNode, checkBoxListSelector) {
        identifiersArray = [];

        if (parentNode) {
            var childrenNodes = $("#" + checkBoxListSelector).igTree("children", parentNode);
            if (childrenNodes && childrenNodes.length > 0) {
                for (var x = 0, len = childrenNodes.length; x < len; x++) {
                    if ($("#" + checkBoxListSelector).igTree("isChecked", childrenNodes[x].element)) {
                        identifiersArray.push(childrenNodes[x].data.Identifier);
                    }
                }
            }
        }

        return identifiersArray;
    };

    // returns the parent (with embedded children) identifiers from the checked items arrays passed
    var getIdentifiersForHierarchical = function (checkedItemsArray, partiallyCheckedItemsArray, checkBoxListSelector) {
        hierIdentifiersArray = [];

        if (checkedItemsArray) {
            for (var x = 0, len = checkedItemsArray.length; x < len; x++) {
                if (checkedItemsArray[x].element && !$("#" + checkBoxListSelector).igTree("parentNode", checkedItemsArray[x].element)) {
                    parentNode = new Object();
                    parentNode.val = checkedItemsArray[x].data.ParentIdentifier;
                    parentNode.childrenVals = getIdentifiersForHierarchicalChild(checkedItemsArray[x].element, checkBoxListSelector);
                    hierIdentifiersArray.push(parentNode);
                }
            }
        }

        if (partiallyCheckedItemsArray) {
            for (var x = 0, len = partiallyCheckedItemsArray.length; x < len; x++) {
                if (partiallyCheckedItemsArray[x].element && !$("#" + checkBoxListSelector).igTree("parentNode", partiallyCheckedItemsArray[x].element)) {
                    parentNode = new Object();
                    parentNode.val = partiallyCheckedItemsArray[x].data.ParentIdentifier;
                    parentNode.childrenVals = getIdentifiersForHierarchicalChild(partiallyCheckedItemsArray[x].element, checkBoxListSelector);
                    hierIdentifiersArray.push(parentNode);
                }
            }
        }

        return hierIdentifiersArray;
    };

    // get all controls of type input and return the filters for query execution
    var getInputFiltersForExecutingSearch = function () {
        var fieldName;
        var controlType;
        var columnName;
        var fieldValue;
        var tempValue;
        var dataType;
        var rangePos;
        var inFltrs = [];

        // process all input controls
        var searchPaneSelector = $(_searchPaneCriteriaGroup);
        searchPaneSelector.find("input").each(function () {

            if (!$(this).hasClass("ui-igcombo-field")) {

                fieldName = $(this).attr('id');

                if (fieldName) {
                    controlType = $("#" + fieldName).attr('data-controlType');
                    columnName = $("#" + fieldName).attr('data-dbcolumn');
                    dataType = $("#" + fieldName).attr('data-dataType');
                    rangePos = $("#" + fieldName).attr('data-rangePosition');
                    _hasCompFltr = _hasCompFltr || isCompanyFilter(columnName);
                    _hasWhsFltr = _hasWhsFltr || isWarehouseFilter(columnName);
                    fieldValue = null;
                    tempValue = null;
                    if (controlType && shouldBeIncludedInFilters(fieldName)) {
                        tempValue = _webUi.editors.getInputValue($("#" + fieldName), tempValue);

                        if (tempValue) {
                            inFltr = new Object();
                            inFltr.type = dataType;

                            inFltr.fld = columnName;
                            if (dataType === "D")
                                inFltr.name = fieldName;
                            else if (columnName.toUpperCase().contains("COALESCE"))
                                inFltr.name = fieldName;

                            if (rangePos === "FROM")
                                inFltr.op = ">=";
                            else if (rangePos === "TO")
                                inFltr.op = "<=";
                            else
                                inFltr.op = "=";

                            inFltr.val = tempValue;
                            inFltrs.push(inFltr);
                        }
                    }
                }
            }
        });

        // process all combo
        var comboSelector = $(_searchPaneCriteriaGroup);
        comboSelector.find("[data-controlType='igCombo']").each(function () {

            fieldName = $(this).attr('id');

            if (fieldName) {
                controlType = $("#" + fieldName).attr('data-controlType');
                columnName = $("#" + fieldName).attr('data-dbcolumn');
                dataType = $("#" + fieldName).attr('data-dataType');

                var allowCustomValue = $("#" + fieldName).igCombo("option", "allowCustomValue");
                var selectedItems = $("#" + fieldName).igCombo("selectedItems");

                if (allowCustomValue && selectedItems == null) {
                    var customValues = $("#" + fieldName).igCombo("value");
                    if(customValues && customValues.length > 0)
                        selectedItems = getIgComboCustomData(customValues[0]);
                }

                
                if (controlType && shouldBeIncludedInFilters(fieldName) && selectedItems && selectedItems[0] && selectedItems[0].data) {
                    tempValue = selectedItems[0].data.Identifier;

                    if (tempValue) {
                        inFltr = new Object();
                        inFltr.type = dataType;
                        if (!columnName)
                            inFltr.name = fieldName;
                        inFltr.fld = columnName;
                        inFltr.op = "=";
                        inFltr.val = tempValue;
                        inFltrs.push(inFltr);
                    }
                }
            }
        });

        if (inFltrs.length > 0)
            return inFltrs;
        else
            return null;
    };

    var getInputValue = function (controlType, fieldName) {

        var fieldValue;

        if (controlType === "igTextEditor")
            fieldValue = $("#" + fieldName).igTextEditor("value");
        else if (controlType === "igDateTimeEditor") 
            fieldValue = $("#" + fieldName).igDateEditor("value");
        else if (controlType === "igDatePicker")
            fieldValue = $("#" + fieldName).igDatePicker("value");
        else if (controlType === "igNumericEditor")
            fieldValue = $("#" + fieldName).igNumericEditor("value");
        else if (controlType === "igCombo") {
            if ($("#" + fieldName).igCombo("option", "allowCustomValue") === true)
                fieldValue = $("#" + fieldName).igCombo("value")[0];

            if ($("#" + fieldName).igCombo("activeIndex") > -1)
            fieldValue = $("#" + fieldName).igCombo("value");
        }

            // todo: insert new types of input controls here as they are created
        else
            fieldValue = null;

        return fieldValue;
    };

    // get all controls of type input and return the filters for saving search
    var getInputFiltersForSavingSearch = function () {
        var fieldName;
        var inFltrs = [];

        // process all input controls
        var searchPaneSelector = $(_searchPaneCriteriaGroup);
        searchPaneSelector.find("input").each(function () {
            fieldName = $(this).attr('name');

            if (fieldName) {
                controlType = $("#" + fieldName).attr('data-controlType');

                if (controlType && shouldBeIncludedInFilters(fieldName)) {
                    fieldValue = getInputValue(controlType, fieldName);

                    if (fieldValue) {
                        inFltr = new Object();
                        inFltr.name = fieldName;
                        inFltr.value = fieldValue;
                        inFltrs.push(inFltr);
                    }
                }
            }
        });

        if (inFltrs.length > 0)
            return inFltrs;
        else
            return null;
    };

    // adds filter to query string and returns
    var addToFiltersQueryString = function (currentQueryString, field, value) {
        var newQueryString = currentQueryString;
        var isFirstParam = false;
        if (!newQueryString) 
            isFirstParam = true;
        newQueryString = newQueryString + (isFirstParam ? (field + "â" + value) : ("," + field + "â" + value));
        return newQueryString;
    };

    // returns filters query string for the filters user has entered
    var getFiltersQueryString = function (filters) {
        var filtersQueryString = "";

        // toggles are different than other controls - they can add filters even if user doesn't do anything, so need to actually just compare the current state vs. initial state
        var searchPaneSelector = $(_searchPaneCriteriaGroup);
        searchPaneSelector.find("[data-controlType='ToggleSwitch']").each(function () {
            fieldId = $(this).attr('id');

            if (fieldId) {
                var initialState = $("#" + fieldId).attr('data-initialState');
                var isOn = $("#" + fieldId).prop('checked');

                if (initialState && ((initialState === "on" && !isOn) || (initialState === "off" && isOn)))
                    filtersQueryString = addToFiltersQueryString(filtersQueryString, fieldId, isOn ? "TRUE" : "FALSE");
            }
        });

        if (filters.inFltrs) {
            for (var x = 0; x < filters.inFltrs.length; x++)
                if (filters.inFltrs[x].type === "D") {
                    var dateValue = removeTimeZoneInfoForDateFields(new Date(dateHandlerForNavTrail(filters.inFltrs[x].val)));
                    filtersQueryString = addToFiltersQueryString(filtersQueryString, filters.inFltrs[x].name ? filters.inFltrs[x].name : filters.inFltrs[x].fld, encodeURIComponent(dateValue));
                }
                else
                    filtersQueryString = addToFiltersQueryString(filtersQueryString, filters.inFltrs[x].name ? filters.inFltrs[x].name: filters.inFltrs[x].fld, encodeURIComponent(filters.inFltrs[x].val));
        }

        if (filters.chkbxFltrs) {
            for (var x = 0; x < filters.chkbxFltrs.length; x++) {
                var value = "";
                var firstValue = true;
                var hasChildValues = false;
                if (filters.chkbxFltrs[x].childrenVals != undefined && filters.chkbxFltrs[x].childrenVals.length > 0)
                    hasChildValues = true;

                if ((filters.chkbxFltrs[x].val[0] && filters.chkbxFltrs[x].val[0] !== "*All")
                    || (filters.chkbxFltrs[x].val[0] && filters.chkbxFltrs[x].val[0] === "*All" && isWarehouseFilter(filters.chkbxFltrs[x].fld))) {
                    for (var y = 0; y < filters.chkbxFltrs[x].val.length; y++) {                        
                        if (firstValue) {
                            value = encodeURIComponent(filters.chkbxFltrs[x].val[y] === "*All" ? "" : filters.chkbxFltrs[x].val[y]);
                            if ($.trim(value) && hasChildValues)
                                value = value + encodeURIComponent(filters.chkbxFltrs[x].childrenVals[y] === "" ? filters.chkbxFltrs[x].childrenVals[y] : " " + filters.chkbxFltrs[x].childrenVals[y]);
                        }
                        else {
                            value = value + "$" + encodeURIComponent(filters.chkbxFltrs[x].val[y] === "*All" ? "" : filters.chkbxFltrs[x].val[y]);
                            if ($.trim(value) && hasChildValues)
                                value = value + encodeURIComponent(filters.chkbxFltrs[x].childrenVals[y] === "" ? filters.chkbxFltrs[x].childrenVals[y] : " " + filters.chkbxFltrs[x].childrenVals[y]);
                        }
                        firstValue = false;
                    }

                    filtersQueryString = addToFiltersQueryString(filtersQueryString, filters.chkbxFltrs[x].fld, value);
                }
            }
        }        

        return filtersQueryString;
    };

    var dateHandlerForNavTrail = function (date) {
        return new Date(date).getTime() - (new Date().getTimezoneOffset() * 60000);
    };

    var removeTimeZoneInfoForDateFields = function (inputValue) {
        if (inputValue) {
            var index = String(inputValue).indexOf("GMT");
            if (index > -1) {
                inputValue = String(inputValue).substring(0, index - 1);
            }
        }

        return inputValue;
    };

    // get count of list pane summary tile fields
    var getTileCount = function () {
        _summaryPanePreviousResponse = {};
        var tileSelector = $("[data-name='ListPaneSummary'],[data-name='MonitorPaneSummary']");
        var summaryTileList = tileSelector.find("[data-controlType='SummaryTile']");
        //Keep list of summary tile
        for (var len = 0; len < summaryTileList.length; len++) {
            var tile = ($(summaryTileList[len]).data('bind').split(":"));
            if(tile.length>1)
                _summaryPanePreviousResponse[tile[1].trim()] = 0;
        }

        return summaryTileList.length;
    };

    // retrieve table/view name from grid attribute
    var getTblNameFromGrid = function () {
        if (!_mainInsightGrid)
            _mainInsightGrid = $(_mainGridAttribute).first();

        return _mainInsightGrid.attr('data-dbtable');
    };

    // gets all controls of type ToggleSwitch and returns the filters for query execution
    var getToggleFiltersForExecutingSearch = function () {
        var fieldId;
        var columnName;
        var positiveCondition;
        var negativeCondition;
        var selectedNode;
        var condition;
        var togFltrs = [];
        var todayDateRangeFrom;
        var todayDateRangeTo;

        // process all toggle controls
        var searchPaneSelector = $(_searchPaneCriteriaGroup);
        searchPaneSelector.find("[data-controlType='ToggleSwitch']").each(function () {
            fieldId = $(this).attr('id');

            if (fieldId) {
                positiveCondition = $("#" + fieldId).attr('data-positiveCondition');
                negativeCondition = $("#" + fieldId).attr('data-negativeCondition');
                columnName = $("#" + fieldId).attr('data-dbcolumn');
                _hasCompFltr = _hasCompFltr || isCompanyFilter(columnName);
                _hasWhsFltr = _hasWhsFltr || isWarehouseFilter(columnName);

                // have to use class as selector here because it's the only way to tell active 
                //node in toggle
                condition = $("#" + fieldId).prop('checked') ? positiveCondition : negativeCondition;

                // if today only toggle is on, passing converted UTC datetime to database as database will be having UTC datetime values
                if (condition === "DATETODAY") {
                    todayDateRangeFrom = new Date(new Date().setHours(0, 0, 0, 0)).toISOString().slice(0, 19).replace('T', ' ');
                    todayDateRangeTo = new Date(new Date().setHours(23, 59, 59, 59)).toISOString().slice(0, 19).replace('T', ' ');
                    toggleFilter = new Object();
                    toggleFilter.fld = columnName;
                    toggleFilter.cond = " >= '"  + todayDateRangeFrom + "'";
                    togFltrs.push(toggleFilter);

                    toggleFilter = new Object();
                    toggleFilter.fld = columnName;
                    toggleFilter.cond = " <= '" + todayDateRangeTo + "'";
                    togFltrs.push(toggleFilter);
                }

                else if (condition) {
                    toggleFilter = new Object();
                    toggleFilter.fld = columnName;
                    toggleFilter.cond = condition;
                    togFltrs.push(toggleFilter);
                }
            }
        });

        if (togFltrs.length > 0)
            return togFltrs;
        else
            return null;
    };
    
    // gets all controls of type ToggleSwitch and returns the filters for saving search
    var getToggleFiltersForSavingSearch = function () {
        var fieldId;
        var selectedNode;
        var togFltrs = [];

        // process all toggle controls
        var searchPaneSelector = $(_searchPaneCriteriaGroup);
        searchPaneSelector.find("[data-controlType='ToggleSwitch']").each(function () {
            fieldId = $(this).attr('id');

            if (fieldId) {
                toggleFilter = new Object();
                toggleFilter.name = fieldId;
                toggleFilter.value = $("#" + fieldId).prop('checked');
                togFltrs.push(toggleFilter);
            }
        });

        if (togFltrs.length > 0)
            return togFltrs;
        else
            return null;
    };

    // is the field passed a company filter?
    var isCompanyFilter = function (columnName) {

        if (!columnName)
            return false;

        return columnName && columnName.toUpperCase() === "COMPANY";
    };

    var isFilterStatementControl = function (controlSelector) {
        return controlSelector[0].hasAttribute("data-insightFilterRecType");
    }

    // is the field passed a warehouse filter?
    var isWarehouseFilter = function (columnName) {
        if (!columnName)
            return false;

        var columnNameUpper = columnName.toUpperCase();
        return columnNameUpper.contains("WAREHOUSE") || columnNameUpper.contains("FROM_WAREHOUSE") || columnNameUpper.contains("FROM_WHS") || columnNameUpper.contains("TO_WAREHOUSE") || columnNameUpper.contains("TO_WHS");
    };

    // should the control be included in the filters?
    var shouldBeIncludedInFilters = function (fieldName) {
        if (fieldName) {
            if (fieldName.indexOf("_Field") > -1 || fieldName.indexOf("_Condition") > -1 || fieldName.indexOf("_Value") > -1
                || fieldName.indexOf("_Operand") > -1 || fieldName.indexOf("_FilterCond") > -1)
                return false;
            else
                return true;
        }

        return false;
    };

    // sets filter badge properly
    var setFilterBadgeCount = function (filters) {
        var filterCount = 0;

        if (filters) {
            // input filters
            if (filters.inFltrs)
                filterCount += filters.inFltrs.length;

            // multi-select
            if (filters.chkbxFltrs) {
                var numChkboxFilters = filters.chkbxFltrs.length;
                for (x = 0; x < numChkboxFilters; x++) {
                    if (filters.chkbxFltrs[x].val && filters.chkbxFltrs[x].val[0] && filters.chkbxFltrs[x].val[0] !== "*All")
                        filterCount++;
                }
            }

            // hierarchical multi-select
            if (filters.hierChkbxFltrs)
                filterCount += filters.hierChkbxFltrs.length;

            // toggles are different than other controls - they can add filters even if user doesn't do anything, so need to actually just compare the current state vs. initial state
            var searchPaneSelector = $(_searchPaneCriteriaGroup);
            searchPaneSelector.find("[data-controlType='ToggleSwitch']").each(function () {
                fieldId = $(this).attr('id');

                if (fieldId) {
                    var initialState = $("#" + fieldId).attr('data-initialState');
                    var isOn = $("#" + fieldId).prop('checked');

                    if (initialState && ((initialState === "on" && !isOn) || (initialState === "off" && isOn)))
                        filterCount++;
                }
            });

            // advanced criteria
            if (filters.advFltrs && filters.advFltrs[0])
                filterCount += filters.advFltrs[0].grdFltrs.length;
        }

        $("#filterBadge").text(filterCount > 0 ? (filterCount + "") : "");
    };

    var setFiltersStorageForAdvancedFilters = function (filters) {
        if (filters && filters.advFltrs && filters.advFltrs[0] && filters.advFltrs[0].grdFltrs) {
            var advancedFilters = [];
            for (var x = 0; x < filters.advFltrs[0].grdFltrs.length; x++) {
                if (filters.advFltrs[0].grdFltrs[x].fld)
                    advancedFilters.push({
                        FieldIdentifier: filters.advFltrs[0].grdFltrs[x].fld,
                        Field: filters.advFltrs[0].grdFltrs[x].fldName,
                        ValueIdentifier: filters.advFltrs[0].grdFltrs[x].val,
                        Value: filters.advFltrs[0].grdFltrs[x].valDsply,
                        Operand: filters.advFltrs[0].grdFltrs[x].opName,
                        OperandIdentifier: filters.advFltrs[0].grdFltrs[x].op,
                        DataType: filters.advFltrs[0].grdFltrs[x].type,
                        ConditionIdentifier: filters.advFltrs[0].cond
                    });
            }
            sessionStorage.setItem(_webUi.insightSearchPaneActions.formId + "advanceCriteriaJson", JSON.stringify(advancedFilters, _webUi.dateReplacer));
        }
        else {
            sessionStorage.removeItem(_webUi.insightSearchPaneActions.formId + "advanceCriteriaJson");
        }
    };

    // public functions
    return {

        formId: 0,
        returnResults: false,
        userClickedSearchButton: false, 

        // set saved search list with knockout
        addToSavedSearchList: function (savedSearchName) {
            setSavedSearchesList(savedSearchName); // this call is part of inline javascript generated in SavedSearchesMenu.cs
        },

        applyInputFilterCriteria: function (inSearch) {
            applySavedInputFilters(inSearch);
        },

        applyInputAdvanceFilterCriteria: function (inSearch, formId) {
            applyAdvanceFilterCriteria(inSearch, formId);
        },

        // choose saved search click event
        applySavedSearchClicked: function (evt) {
            serviceParameters = new Object();
            serviceParameters.ScreenPartId = _webUi.insightSearchPaneActions.getSearchPartId();
            serviceParameters.UserName = _webSession.UserName();
            serviceParameters.searchName = $(evt.target).text();

            //delete saved search
            if (serviceParameters.searchName == "") {
                _webUi.dialog.showYesNoConfirmation($('#deleteSavedSerachMessage').val(), "MSG_DELETEFAVORITE01").then(function (confirmed) {
                    //this explictly triggers click event on the favorite seach using bootstrap to make it expanded. 
                    $('#SearchPaneMenuFavoritesDropdown').trigger('click.bs.dropdown');

                    if (confirmed) {
                        serviceParameters.searchName = $(evt.target).parent().text();
                        // clicked yes, call delete
                        _httpRequest.performDelete("/general/scaleapi/ScreenPartSearchApi?" + $.param(serviceParameters), applyRemoveSavedSearchCallback, null,

true);
                    }
                    else {
                        // clicked no . . . re-show original dialog prompt
                    }
                });
            }
                //apply saved search
            else {
                _httpRequest.performGet("/general/scaleapi/ScreenPartSearchApi?" + $.param(serviceParameters), applySavedSearchCallback, null, false, false);
            }
        },

        // returns all filter criterias as JSON object
        getAllFilterCriterias: function () {
            return getFiltersForExecutingSearch();
        },

        // search button clicked event
        searchButtonClicked: function () {
            $(this).focus();
            _webUi.insightSearchPaneActions.returnResults = true;
            // retrieve filters
            _filtersToExecute = getFiltersForExecutingSearch();

            // store off current filters for nav trail
            _webUi.navigationTrail.setFiltersForCurrentInsightScreen(_webUi.insightSearchPaneActions.formId, _filtersToExecute, getFiltersQueryString(_filtersToExecute));
            setFiltersStorageForAdvancedFilters(_filtersToExecute);

            // fill list pane based on filters
            fillListPaneGridBasedOnSearchFilters(JSON.stringify(_filtersToExecute, _webUi.dateReplacer));

            _webUi.insightSearchPaneActions.returnResults = false;//reset this flag
        },

        // clear button clicked event
        clearButtonClicked: function () {            
            // clear filters
            clearAndEnableOrDisableSearchPaneControlsOtherThanFilterStatement(true, true, true);

            // now clear filter and badge
            getFiltersForExecutingSearch();
        },

        //stop search button clicked event
        stopSearchButtonClicked: function () {
            try{
                _mainInsightGrid.data("igGrid").dataSource._ajaxRequest.abort();            
            }
            catch(err)
            {}
        },

        //request error gets fired on abort of ajax request of grid
        insightGridRequestError: function (evt,ui) {
            _mainInsightGrid.data("igGrid")._loadingIndicator.hide();
            $('#InsightMenuActionStopSearch').closest('li').addClass("dropdownaction disabled");
        },

        //disable stop search button on databound
        insightGridDataBound: function() {
            $('#InsightMenuActionStopSearch').closest('li').addClass("dropdownaction disabled");
        },        

        // method sets list pane datasource based on passed in filters
        setMainInsightGridDataSource: function (filtrs) {
            if (!_mainInsightGrid)
                _mainInsightGrid = $(_mainGridAttribute).first();

            // save off the url with token in it so that we can replace the token each time they hit search
            var currentGridUrl = _mainInsightGrid.igGrid("option", "dataSource");
            if (!_gridUrlWithToken)
                _gridUrlWithToken = currentGridUrl;

            var newGridUrl = _gridUrlWithToken.replace(/filterToken/g, encodeURIComponent(filtrs)); // "g" is flag for global replacement
            _mainInsightGrid.data("igGrid").dataSource.settings.dataSource = newGridUrl;
        },

        // retrieve search part id
        getSearchPartId: function () {
            var screenPartContainingMenus = $(_insightMenuPanePart).attr('data-internalid');
            if (screenPartContainingMenus)
                return screenPartContainingMenus;
            else
                return $(_searchPanePart).attr('data-internalid');
        },

        // returns json for the search that will be saved
        getSearchToSave: function () {
            return getFiltersForSavingSearch();
        },

        // fill list pane summary tiles
        fillListPaneSummaryTiles: function (responseData) {
            // only retrieve filters if they weren't retrieved previously
            if (!_filtersToExecute)
                _filtersToExecute = getFiltersForExecutingSearch();
                        
                // fill list pane tiles based on filters
            if (getTileCount() > 0) {

                //If response is null, set responseData with previous value.
                if ((responseData == null || responseData == undefined) && _summaryPanePreviousResponse != null) {
                    responseData = _summaryPanePreviousResponse;
                }
                    $.each(responseData, function (i, theItem) {
                        try {
                            _webUi.label.bindLabel(i, theItem);
                        }
                        catch (error) {
                            alert('error found' + error);
                        }
                    });
                }            

            // set the filters back to null so that it is captured fresh next time
            _filtersToExecute = null;
        },

        // saved search success callback
        saveSearchSuccessCallback: function (data, textStatus, jqXHR) {
            setSavedSearchesList(data.SearchName); // this call is part of inline javascript generated in SavedSearchesMenu.cs
        },

        queryStringGridFilters: getFilterCriteriaFromQueryString(),
        queryStringAdvanceGridFilters: getAdvancedFilterCriteriaFromQueryString(formId)
    }
}();
;